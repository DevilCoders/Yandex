include include/s3/shared_dicts.conf;

init_worker_by_lua_block {
  local S3Lib = require "s3.lib"
  S3Lib.initWorker()
}

server {
  listen 8888;
  listen [::]:8888;

  server_name
    s3.mds.yandex.net
    *.s3.mds.yandex.net
    s3.mdst.yandex.net
    *.s3.mdst.yandex.net;

  include include/s3/values.conf;

  location / {
    rewrite_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.init()
      S3Lib.route()
    }

    access_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.limitBucketRate()
    }

    header_filter_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.fillHeaders()
    }

    content_by_lua_block {
      ngx.say("internal")
      ngx.say("bucket: " .. ngx.var.s3_bucket_name)
      ngx.say("is_public: " .. ngx.var.s3_public_request)
    }

    body_filter_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.countBucketReadTraffic()
    }
  }

  location /tests/s3-private-api-client {
    content_by_lua_block {
      local S3PrivateAPI = require "s3.private-api"
      local JSON = require "cjson"

      local client = S3PrivateAPI:new()
      local buckets, err = client:buckets_opened()
      if err then
        ngx.status = ngx.HTTP_INTERNAL_SERVER_ERROR
        ngx.say("failed to load external buckets settings from S3 Private API: " .. tostring(err))
        ngx.exit(ngx.HTTP_OK)
      end

      ngx.status = ngx.HTTP_OK
      ngx.say(JSON.encode(buckets))
      ngx.exit(ngx.HTTP_OK)
    }
  }

  location /tests/lock {
    content_by_lua_block {
      local S3Lock = require "s3.lock"

      local lock = S3Lock:new("s3_locks", "test-lock-name", "worker PID " .. tostring(ngx.worker.pid()))
      local locked, err = lock:try_lock(20)

      if locked then
        ngx.status = ngx.HTTP_OK
        ngx.say("obtained a lock")
        ngx.flush()
        ngx.sleep(10)
        lock:unlock()
        ngx.say("released a lock")
      else
        ngx.status = ngx.HTTP_NOT_FOUND
        ngx.say("failed to get lock: " .. tostring(err))
      end

      ngx.exit(ngx.HTTP_OK)
    }
  }
}

server {
  listen 8888;
  listen [::]:8888;

  server_name
    s3.yandex.net
    *.s3.yandex.net;

  include include/s3/values.conf;

  location / {
    content_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.init()
      S3Lib.checkPublicAccessAllowed()
      S3Lib.route()
    }
  }

  location /tests/external-access/update {
    content_by_lua_block {
      local S3OpenBuckets = require "s3.open_buckets"
      S3OpenBuckets.refresh(30)
    }
  }

  location /tests/external-access/check {
    location ~* /tests/external-access/check/(.*) {
      content_by_lua_block {
        local S3Lib = require "s3.lib"
        S3Lib.checkPublicAccessAllowed(ngx.var[1])
      }
    }
  }

  location /tests/external-access/get-allowed-buckets {
    content_by_lua_block {
      local dict = ngx.shared["s3_open_buckets"]
      local JSON = require "cjson"
      ngx.say("the keys are: '" .. JSON.encode(dict:get_keys(0)) .."'")
    }
  }

  location /tests/external-access/get-allowed-regexes {
    content_by_lua_block {
      local dict = ngx.shared["s3_open_buckets_regex"]
      local JSON = require "cjson"
      ngx.say("the keys are: '" .. JSON.encode(dict:get_keys(0)) .."'")
    }
  }

  location @s3_default_route {
    access_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.limitBucketRate()
    }

    header_filter_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.fillHeaders()
    }

    body_filter_by_lua_block {
        local S3Lib = require "s3.lib"
        S3Lib.countBucketReadTraffic()
    }

    return 200 "public\nname: $s3_bucket_name\nis_public: $s3_public_request\n";
  }
}

server {
  listen 8888;
  listen [::]:8888;

  server_name
    s3-staff.mds.yandex.net
    *.s3-staff.mds.yandex.net;

  include include/s3/values.conf;

  location / {
    content_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.init()
      S3Lib.checkStaffAccessAllowed()
      S3Lib.route()
    }
  }

  location /tests/external-access/update {
    content_by_lua_block {
      local S3OpenBuckets = require "s3.open_buckets"
      S3OpenBuckets.refresh(30)
    }
  }

  location /tests/external-access/check {
    location ~* /tests/external-access/check/(.*) {
      content_by_lua_block {
        local S3Lib = require "s3.lib"
        S3Lib.checkStaffAccessAllowed(ngx.var[1])
      }
    }
  }

  location /tests/external-access/get-allowed-buckets {
    content_by_lua_block {
      local dict = ngx.shared["s3_open_buckets"]
      local JSON = require "cjson"
      ngx.say("the keys are: '" .. JSON.encode(dict:get_keys(0)) .."'")
    }
  }

  location /tests/external-access/get-allowed-regexes {
    content_by_lua_block {
      local dict = ngx.shared["s3_open_buckets_regex"]
      local JSON = require "cjson"
      ngx.say("the keys are: '" .. JSON.encode(dict:get_keys(0)) .."'")
    }
  }

  location @s3_default_route {
    access_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.limitBucketRate()
    }

    header_filter_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.fillHeaders()
    }

    body_filter_by_lua_block {
        local S3Lib = require "s3.lib"
        S3Lib.countBucketReadTraffic()
    }

    return 200 "public\nname: $s3_bucket_name\nis_public: $s3_public_request\n";
  }
}

server {
  listen 8888;
  listen [::]:8888;

  server_name
    s3-private.mds.yandex.net
    *.s3-private.mds.yandex.net
    s3-private.mdst.yandex.net
    *.s3-private.mdst.yandex.net;

  include include/s3/values.conf;

  location / {
    content_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.init()
      S3Lib.checkPrivateAccessAllowed()
      S3Lib.route()
    }
  }

  location /tests/external-access/update {
    content_by_lua_block {
      local S3OpenBuckets = require "s3.open_buckets"
      S3OpenBuckets.refresh(30)
    }
  }

  location /tests/external-access/check {
    location ~* /tests/external-access/check/(.*) {
      content_by_lua_block {
        local S3Lib = require "s3.lib"
        S3Lib.checkPrivateAccessAllowed(ngx.var[1])
      }
    }
  }

  location /tests/external-access/get-allowed-buckets {
    content_by_lua_block {
      local dict = ngx.shared["s3_open_buckets"]
      local JSON = require "cjson"
      ngx.say("the keys are: '" .. JSON.encode(dict:get_keys(0)) .."'")
    }
  }

  location /tests/external-access/get-allowed-regexes {
    content_by_lua_block {
      local dict = ngx.shared["s3_open_buckets_regex"]
      local JSON = require "cjson"
      ngx.say("the keys are: '" .. JSON.encode(dict:get_keys(0)) .."'")
    }
  }

  location @s3_default_route {
    access_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.limitBucketRate()
    }

    header_filter_by_lua_block {
      local S3Lib = require "s3.lib"
      S3Lib.fillHeaders()
    }

    body_filter_by_lua_block {
        local S3Lib = require "s3.lib"
        S3Lib.countBucketReadTraffic()
    }

    return 200 "private\nname: $s3_bucket_name\nis_public: $s3_public_request\n";
  }
}

server {
  listen 8888;
  listen [::]:8888;

  server_name
    s3-idm.mds.yandex.net
    s3-idm.mdst.yandex.net;

  include include/s3/values.conf;

  location /buckets/opened {
    root /data;
    try_files /buckets_opened.json =404;
  }
}
