#!/bin/sh

# summary of how this script can be called:
# * <postinst> `configure' <most-recently-configured-version>
# * <old-postinst> `abort-upgrade' <new version>
# * <conflictor's-postinst> `abort-remove' `in-favour' <package> <new-version>
# * <postinst> `abort-remove'
# * <deconfigured's-postinst> `abort-deconfigure' `in-favour'
#   <failed-install-package> <version> `removing'
#   <conflicting-package> <version>
#
# for details, see dh_installdeb(1) or http://www.debian.org/doc/debian-policy/

set -e
set -x

# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

delete_unnecessary_udev_rules() {
    echo "Delete unnecessary udev rules"
    rm -f /etc/udev/rules.d/82-net-setup-link.rules
    rm -f /lib/udev/rules.d/82-net-setup-link.rules
}

gen_mellanox_mod_options() {
        if lspci -d ::0200 -n | grep "$MLNX_CX3" -q
        then
            # NOTE(simonov-d): mellanox cx3 supports up to 63 VFs (in firmware), but kernel 4.9
            # doesn't boot with 63 VFs (4.14 boots OK). For details, see CLOUD-7327
            mlx4_core_options="port_type_array=2,2 num_vfs=16,0,0 probe_vf=16,0,0"
        else
            # NOTE(k-zaitsev): probably a mellanox cx3-pro from MAN dc. They have hard limitation on 8 in fw
            mlx4_core_options="port_type_array=2,2 num_vfs=8,0,0 probe_vf=8,0,0"
        fi
        echo "options mlx4_core $mlx4_core_options" > /etc/modprobe.d/mlx4_vf.conf
        update-initramfs -u
}

split_nvme() {
        echo "Split NVMe into namespaces"
        python3 /usr/bin/nvme_split.py
}

create_part_label() {
        echo "Create label on first partition on NVME3"
        python3 /usr/bin/nvme_part_label.py
}

rebuild_dkms() {
        echo "Rebuilding dkms modules"
        echo "dkms autoinstall -k $(dpkg -l|grep linux-image|grep yc|awk '{print $3}')"
        dkms autoinstall -k $(dpkg -l|grep linux-image|grep yc|awk '{print $3}')
}

enable_mst() {
	systemctl enable mst
}

check_hostname(){
  set +e
  node_name="$(hostname -f)"
  if [ "$?" -ne 0 ]
  then
    echo 'Node`s FQDN not set. Please, correct it and restart setup'
    echo 'May be Wall-E`s Check DNS helps you'
    exit 1
  fi
  set -e
}

get_current_infra_endpoints() {
  node_name="$(hostname -f)"
  env_file="/etc/profile.d/infra.sh"
  if [ $(echo "${node_name}" | grep -c "gpn") -eq 1 ]; then
    echo "${node_name} is a GPN host. Setting appropriate endpoints"
    INFRA_PROXY="https://infra-proxy.proxy.gpn.yandexcloud.net"
    DIST_URL="dist.proxy.gpn.yandexcloud.net"
    WALLE_URL="https://api.wall-e.proxy.gpn.yandexcloud.net"
  elif [ $(echo "${node_name}" | grep -c "private-testing") -eq 1 ]; then
    echo "${node_name} is a PRIVATE-TESTING host. Setting appropriate endpoints"
    INFRA_PROXY="https://infra-proxy.private-testing-proxy.cloud.yandex.net"
    DIST_URL="dist.private-testing-proxy.cloud.yandex.net"
    WALLE_URL="https://api.wall-e.private-testing-proxy.cloud.yandex.net"
  else
    echo "${node_name} is a usual host. Setting appropriate endpoints"
    INFRA_PROXY="https://infra-proxy.cloud.yandex.net"
    DIST_URL="dist.yandex.ru"
    WALLE_URL="https://api.wall-e.yandex-team.ru"
  fi
  export INFRA_PROXY=${INFRA_PROXY}
  export DIST_URL=${DIST_URL}
  export WALLE_URL=${WALLE_URL}

  if [ ! -f "${env_file}" ]; then
    touch ${env_file}
  fi

  for item in INFRA_PROXY DIST_URL WALLE_URL
  do
    if [ $(grep -c "${item}" "${env_file}") -eq 0 ]; then
      value=$(eval echo \${$item})
      echo "export ${item}=$value" >> ${env_file}
    fi
  done

}


case "$1" in
    configure)
check_hostname
delete_unnecessary_udev_rules
get_current_infra_endpoints
split_nvme
create_part_label
if [ "$(lsb_release -sc)" = "xenial" ]; then
  rebuild_dkms
fi
gen_mellanox_mod_options
enable_mst

        ;;

    abort-upgrade|abort-remove|abort-deconfigure)
        ;;

    *)
        echo "postinst called with unknown argument '$1'" >&2
        exit 1
        ;;
esac

exit 0
