syntax = "proto3";

package yandex.cloud.priv.disk_manager.v1;

import "google/protobuf/empty.proto";
import "yandex/cloud/api/operation.proto";
import "yandex/cloud/priv/disk_manager/v1/disk.proto";
import "yandex/cloud/priv/operation/operation.proto";
import "yandex/cloud/priv/sensitive.proto";

option go_package = "a.yandex-team.ru/cloud/disk_manager/api/yandex/cloud/priv/disk_manager/v1;disk_manager";

service DiskService {
    rpc Create(CreateDiskRequest) returns (operation.Operation) {
        option (yandex.cloud.api.operation) = {
            metadata: "CreateDiskMetadata"
            response: "google.protobuf.Empty"
        };
    }

    // Delete the disk without deleting its snapshots.
    rpc Delete(DeleteDiskRequest) returns (operation.Operation) {
        option (yandex.cloud.api.operation) = {
            metadata: "DeleteDiskMetadata"
            response: "google.protobuf.Empty"
        };
    }

    rpc Resize(ResizeDiskRequest) returns (operation.Operation) {
        option (yandex.cloud.api.operation) = {
            response: "google.protobuf.Empty"
        };
    }

    rpc Alter(AlterDiskRequest) returns (operation.Operation) {
        option (yandex.cloud.api.operation) = {
            response: "google.protobuf.Empty"
        };
    }

    // Should be called before starting the VM with proper token.
    rpc Assign(AssignDiskRequest) returns (operation.Operation) {
        option (yandex.cloud.api.operation) = {
            response: "google.protobuf.Empty"
        };
    }

    // Should be called after stopping the VM.
    rpc Unassign(UnassignDiskRequest) returns (operation.Operation) {
        option (yandex.cloud.api.operation) = {
            response: "google.protobuf.Empty"
        };
    }

    rpc DescribeModel(DescribeDiskModelRequest) returns (DiskModel) {}

    rpc Stat(StatDiskRequest) returns (DiskStats) {}

    // Creates a disk in the destination zone and starts replicating data to it from the source disk, and after replication is finished, replaces the source disk with the destination disk.
    //
    // In order to finish this operation, firstly FINISH_REPLICATION, and then FINISH_MIGRATION signals should be sent via |SendMigrationSignal|.
    //
    // Can be cancelled by performing |operations.Cancel| on returned operation, but only before FINISH_MIGRATION signal has been sent.
    rpc Migrate(MigrateDiskRequest) returns (operation.Operation) {
        option (yandex.cloud.api.operation) = {
            metadata: "MigrateDiskMetadata"
            response: "google.protobuf.Empty"
        };
    }

    // Sends a signal to the migration operation, advancing migration process forward.
    rpc SendMigrationSignal(SendMigrationSignalRequest) returns (google.protobuf.Empty) {
        option (yandex.cloud.api.operation) = {
            response: "google.protobuf.Empty"
        };
    }
}

message CreateDiskRequest {
    oneof src {
        google.protobuf.Empty src_empty = 1;
        // It's (generally) very fast to create disk from image, because it'll create a layered disk basing on some disk from image's pool
        string src_image_id = 2;
        // This is similar to creating from Image, except it performs full copy and so is very slow.
        string src_snapshot_id = 3;
    }
    int64 size = 4;
    DiskId disk_id = 5;
    int64 block_size = 6;
    DiskKind kind = 7;
    string cloud_id = 8;
    string folder_id = 9;
    int64 tablet_version = 10;
    string placement_group_id = 11;
    // Prevents from creating layered (overlay) disk.
    bool force_not_layered = 12;
    string operation_cloud_id = 13;
    string operation_folder_id = 14;
    EncryptionMode encryption_mode = 15;
    string encryption_key_file_path = 16;
    string storage_pool_name = 17;
    repeated string agent_ids = 18;
}

message CreateDiskMetadata {
    double progress = 1;
}

message DeleteDiskRequest {
    reserved 2;

    DiskId disk_id = 1;
}

message DeleteDiskMetadata {
    DiskId disk_id = 1;
}

message ResizeDiskRequest {
    DiskId disk_id = 1;
    int64 size = 2;
}

message AlterDiskRequest {
    DiskId disk_id = 1;
    string cloud_id = 2;
    string folder_id = 3;
}

message AssignDiskRequest {
    DiskId disk_id = 1;
    string instance_id = 2;
    string host = 3;
    // Empty token is not allowed.
    string token = 4 [(sensitive) = true];
}

message UnassignDiskRequest {
    DiskId disk_id = 1;
}

message DescribeDiskModelRequest {
    string zone_id = 1;
    int64 block_size = 2;
    int64 size = 3;
    DiskKind kind = 4;
    int64 tablet_version = 5;
}

message StatDiskRequest {
    DiskId disk_id = 1;
}

message MigrateDiskRequest {
    DiskId disk_id = 1;
    string dst_zone_id = 2;
}

message MigrateDiskMetadata {
    enum Status {
        STATUS_UNSPECIFIED = 0;
        REPLICATING = 1;
        FINISHING_REPLICATION = 2;
        REPLICATION_FINISHED = 3;
        FINISHING = 4;
        FINISHED = 5;
    }

    Status status = 1;
    double progress = 2;
    int64 seconds_remaining = 3; // To copy the rest of the data.
}

message SendMigrationSignalRequest {
    enum Signal {
        SIGNAL_UNSPECIFIED = 0;
        // Signal to freeze source disk and finish data replication.
        FINISH_REPLICATION = 1;
        // Signal to delete source disk and replace it with destination disk. Can only be sent after FinishReplication signal.
        FINISH_MIGRATION = 2;
    }

    string operation_id = 1;
    Signal signal = 2;
}
