import typing
import functools

from concurrent import futures

from yc_common.context import apply_context
from yc_common.clients.kikimr.exceptions import TableNotFoundError
from yc_common.clients.kikimr.client import KikimrTable, KikimrCursorSpec, get_kikimr_client
from yc_common.clients.kikimr.util import retry_idempotent_kikimr_errors
from yc_common.clients.kikimr import sql
from yc_common.exceptions import LogicalError
from yc_common import logging, paging, exceptions


_UPSERT_PAGE_MAX_SIZE = 512
_UPSERT_MAX_WORKERS = 8

log = logging.get_logger(__name__)


def create_table(table: KikimrTable):
    _create_table(table)


def drop_table(table: KikimrTable):
    _drop_table(table, only_if_exists=True)


def alter_table_add_columns(table: KikimrTable):
    desired_spec = table.initial_spec()
    current_spec = table.current_spec()

    if current_spec.primary_keys != desired_spec.primary_keys:
        raise exceptions.Error("Primary keys was changed.")

    to_add = set(desired_spec.columns.keys()) - set(current_spec.columns.keys())
    _alter_table_in_place(table, columns_to_add={
        name: data_type for name, data_type in desired_spec.columns.items() if name in to_add
    })


def alter_table_drop_columns(table: KikimrTable):
    desired_spec = table.initial_spec()
    current_spec = table.current_spec()

    if current_spec.primary_keys != desired_spec.primary_keys:
        raise exceptions.Error("Primary keys was changed.")

    to_drop = set(current_spec.columns.keys()) - set(desired_spec.columns.keys())
    _alter_table_in_place(table, columns_to_drop=to_drop)


def upsert_to_table(table: KikimrTable):
    """
    Decorator, what upsert rows generated by func to table
    """

    def decorator(func: typing.Callable[[int], typing.Optional[dict]]) -> typing.Callable[[], None]:
        @functools.wraps(func)
        def wrapper():
            def generator() -> typing.Iterable[dict]:
                index = 0
                while True:
                    row = func(index)
                    if row is None:
                        break

                    index += 1
                    yield row

            _upsert_to_table(table, row_generator=generator())

        return wrapper

    return decorator


def map_table(table: KikimrTable, max_select_rows=100, inplace=False):
    table_spec = table.initial_spec()

    columns = sorted(table_spec.columns.keys())
    primary_keys = table_spec.primary_keys

    def _make_primary_values(rows):
        result = []
        for row in rows:
            result.append([row[k] for k in primary_keys])
        return result

    def _make_cursor(table_name, cursor_columns, cursor_values):
        return cursor_values

    def _parse_cursor(table_name, cursor_columns, cursor_values):
        return cursor_values

    @retry_idempotent_kikimr_errors
    def _process_rows(db, func, rows):
        with db.transaction() as tx:
            with tx.table_scope(table):
                rows = list(tx.select(
                    "SELECT * FROM $table WHERE ?",
                    sql.SqlCompoundKeyMatch(primary_keys, _make_primary_values(rows))
                ))

            if rows:
                func(tx, rows)

                if inplace:
                    values = []

                    for row in rows:
                        row_columns = sorted(row.keys())

                        if row_columns != columns:
                            raise LogicalError(
                                "Got a row from {!r} table which columns don't equal to the expected ones: {} vs {}.",
                                table.name, row_columns, columns)

                        values.append([row[column] for column in columns])

                    with tx.table_scope(table):
                        tx.query("REPLACE INTO $table ?", sql.SqlInsertValues(columns, values))

            return len(rows)

    def decorator(func):
        @functools.wraps(func)
        def wrapper():
            db = get_kikimr_client(table.database_id)
            next_page_token = None
            counter = 0

            while True:
                rows, next_page_token = paging.select_one_page(
                    KikimrCursorSpec(table, cursor_value=next_page_token, cursor_limit=max_select_rows),
                    db.with_table_scope(table),
                    "SELECT * FROM $table WHERE ? ?",
                    sql.SqlCursorCondition(), sql.SqlCursorOrderLimit(),
                    make_cursor=_make_cursor,
                    parse_cursor=_parse_cursor,
                )

                counter += _process_rows(db, func, rows)
                if counter % 500 == 0:
                    log.info("%s rows have been processed...", counter)
                if next_page_token is None:
                    break

            log.info("Total %s rows have been processed.", counter)

        return wrapper

    return decorator


class _AsyncProcessor:
    def __init__(self, max_workers: int):
        self.__executor = futures.ThreadPoolExecutor(max_workers=max_workers)
        self.__futures = set()
        self.__max_workers = max_workers

    def __enter__(self):
        self.__executor.__enter__()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.__executor.__exit__(exc_type, exc_val, exc_tb)

    @property
    def max_workers(self):
        return self.__max_workers

    @property
    def queue_size(self):
        return len(self.__futures)

    def submit(self, fn: typing.Callable, *args, **kwargs):
        self.__futures.add(
            self.__executor.submit(apply_context(fn), *args, **kwargs))

    def wait(self, return_when=futures.ALL_COMPLETED) -> typing.List[typing.Any]:
        done, not_done = futures.wait(self.__futures, return_when=return_when)
        self.__futures = not_done
        return [f.result() for f in done]


def _upsert_to_table(
        table: KikimrTable, row_generator: typing.Iterable[dict]):

    def generate_query(content: typing.List[dict]) -> (str, list, int):
        row = content[0]
        values = []
        query_values = ["({})".format(
            ", ".join([sql.VALUE_PLACEHOLDER] * len(row)))] * len(content)

        for r in content:
            values.extend(r.values())

        query = "UPSERT INTO $table ({columns}) VALUES {values}".format(
            columns=", ".join(row.keys()), values=", ".join(query_values))

        return query, values

    @retry_idempotent_kikimr_errors
    def execute_query(q, v):
        with table.client.transaction() as tx:
            tx.query(q, *v)
            tx.commit()

    def wait_if_needed(p: _AsyncProcessor):
        max_workers = p.max_workers

        if p.queue_size > max_workers * 2:  # works like double buffer :)
            while p.queue_size > max_workers:
                p.wait(return_when=futures.FIRST_COMPLETED)

    log.info("Begin upsert rows to %r table...", table.name)

    with _AsyncProcessor(max_workers=_UPSERT_MAX_WORKERS) as processor:
        page_counter = 0
        page = []

        for row in row_generator:
            page.append(row)
            if len(page) == _UPSERT_PAGE_MAX_SIZE:
                processor.submit(execute_query, *generate_query(page))
                page.clear()

                page_counter += 1
                if page_counter % 10 == 0:
                    log.info("Processed %r rows...", page_counter * _UPSERT_PAGE_MAX_SIZE)

                wait_if_needed(processor)

        if page:
            processor.submit(execute_query, *generate_query(page))

        processor.wait()

    log.info("Upsert rows to %r table completed.", table.name)


def _create_table(table: KikimrTable):
    table.create()
    log.info("Created %r table.", table.name)


def _drop_table(table: KikimrTable, only_if_exists: bool=False):
    try:
        table.drop()
        log.info("Dropped %r table.", table.name)
    except TableNotFoundError:
        if not only_if_exists:
            raise


def _alter_table_in_place(
        table: KikimrTable,
        columns_to_add: typing.Optional[typing.Dict[str, str]]=None,
        columns_to_drop: typing.Optional[typing.Set[str]]=None):

    if columns_to_add:
        for name, data_type in columns_to_add.items():
            table.add_column(name, data_type)

        log.info("%r columns added to %r table.", columns_to_add, table.name)

    if columns_to_drop:
        for name in columns_to_drop:
            table.drop_column(name)

        log.info("%r columns dropped from %r table.", columns_to_drop, table.name)


def _get_table_copy(
        original_table: KikimrTable, name: str,
        only_if_exists: bool=False) -> typing.Optional[KikimrTable]:

    table_copy = KikimrTable(
        original_table.database_id, name,
        original_table.current_spec())

    if not table_copy.is_exists():
        if only_if_exists:
            return None

        get_kikimr_client(original_table.database_id).copy_table(
            original_table.path, table_copy.path)

        log.info("Created %r table copy with name: %r.",
                 original_table.name, table_copy.name)

    return table_copy


def _get_table_clone(
        original_table: KikimrTable, name: str,
        only_if_exists: bool=False) -> typing.Optional[KikimrTable]:

    table_clone = KikimrTable(
        original_table.database_id, name,
        original_table.current_spec())

    if not table_clone.is_exists():
        if only_if_exists:
            return None

        table_clone.create()
        log.info("Created %r table clone with name: %r.",
                 original_table.name, table_clone.name)

    return table_clone
