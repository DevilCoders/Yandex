# Библиотека общих Python-компонентов облака

`python-common` представляет из себя библиотеку общих Python-компонентов Облака,
которая предоставляет как Python-пакеты, предназначенные для использования в более
чем одном сервисе, так и скрипты настройки разработческого окружения и сборки
deb-пакетов для использования в production.

В нашем проекте было принято решение, что все сервисы распространяются в виде
deb-пакетов, в которых вендорятся все Python-зависимости. Таким образом, каждый
deb-пакет сервиса несет в себе Python'овский virtual environment со всеми
зависимыми пакетами.

Для удобства разработки сам `python-common` всегда подключается в проект в виде
[сабмодуля](https://git-scm.com/book/en/v2/Git-Tools-Submodules) и не заливается
в PyPI - это сильно ускоряет разработку в случае, когда для разработки необходимого
функцонала в сервисе необходимо внести изменения в `python-common`, что на начальном этапе
разработки довольно частое явление.

Каждый сервис имеет свою копию завендоренных пакетов, которые хранятся в директории
`vendor`. Библиотеки вроде `python-common` свои зависимости не вендорят (точнее -
вендорят, но данный вендоринг используется исключительно для создания virtual
environment для запуска unit-тестов).

Сама директория `vendor` выносится в отдельный репозиторий и тоже подключается в виде
сабмодуля, чтобы не раздувать основной репозиторий. Это имеет смысл, т. к. репозиторий
с `vendor` очень быстро распухает от всех этих `*.tar.gz`, а, имея отдельный репозиторий,
мы можем быстро и безболезненно периодически сокращать его размер, отрезая старую историю
и при этом никак не трогая историю репозитория с кодом.

Таким образом получается, что результирующий репозиторий сервиса всегда содержит
несколько сабмодулей - в том числе рекурсивных (один сабмодуль содержит другие),
поэтому после клонирования любого нашего репозитория необходимо выполнить команду
`git submodule update --init --recursive`, чтобы выкачать все дерево сабмодулей.

P.S.: Каждый, кто хоть раз пользовался git'овыми сабмодулями, знает: сабмодули - это
зло, жизнь с ними трудна и полна ненависти и случайных ошибок, но на данном этапе
развития инфраструктуры нашего проекта плюсов от них больше, чем минусов.


## Перевод нового проекта на технологии python-common

Подключаем `common` к репозиторию:
```bash
git submodule ssh://git@bb.yandex-team.ru/cloud/python-common.git common
git submodule update --init --recursive
git commit
```

Создаем директорию, в которой будет располагаться код нашего проекта. Дерево данной
директории должно иметь следующий вид (для сервиса с именем `example-service`):
```
example_service/
├── .python-version
├── MANIFEST.in
├── bin
│   └── yc-example-service
├── requirements.txt
├── setup.py
├── vendor.txt
└── yc_example_service
    ├── __init__.py
    └── *.py
```

Что стоит отметить:
* Важно иметь файл `requirements.txt`, т. к. именно с помощью таких файлов будет
  строиться дерево зависимостей сервиса. Если сервис пользуется пакетами из
  `python-common`, то в `requirements.txt` должна быть зависимость на `yc_common`.
* В `.python-version` должна быть версия интерпретатора 3.5.2, которая используется
  в дистрибутиве, поверх которого работает наше облако (Ubuntu Xenial) - в данный
  момент наш процесс вендоринга в одном месте заточен именно на версию 3.5.
* Зависимости берутся из репозитория pypi.yandex-team.ru.
* В необязательном файле vendor.txt должны быть перечислены зависимости, которые
  нельзя по-простому получить в исходниках pip-ом из репозитория и собрать. Можно
  указать названия модулей для которых pip скачает бинарные пакеты. Модули перечисляются
  вместе с опциями коммандной стоки, передаваемыми напрямую в pip. Кроме этого, можно
  указать URL к архивам с модулями, которых нет в репозитории.
  Пример содержимого vendor.txt:
  ```
  yc-snapshot-client --platform macosx_10_6_intel --no-deps
  yc-snapshot-client --platform linux_x86_64 --no-deps
  https://launchpad.net/ubuntu/+archive/primary/+files/python-apt_1.1.0~beta1build1.tar.xz
  ```

Рассматирвать содержимое других файлов не будем – их с легкостью можно сделать по аналогии с
остальными сервисами.

Далее необходимо создать `Makefile`. В простейшем случае достаточно просто сделать
symlink на уже существующий:
```bash
ln -s common/scripts/project.mk Makefile
```

Теперь вендорим все зависимости:
* Создаем репозиторий с суффиксом `-vendor`
* Подключаем его в качестве сабмодуля - `git submodule add ssh://git@bb.yandex-team.ru/cloud/$name-vendor.git vendor`
* Запускаем `make vendor` - он удалит содержимое директории `vendor` и скачает туда все зависимости проекта.
* Коммитим изменения в `vendor` (не забывая закоммитить изменения ревизии `vendor` в репозитории проекта).


## Создание виртуального окружения для разработки

Для того, чтобы можно было удобно работать над проектом, нам необходимо создать для него
virtual environment, поставить в него все зависимости, но кроме тех, которые находятся
в нашем репозитории - их нужно просто подлинковать в вирутальное окружение, чтобы можно
было менять код и тут же видеть результат.

Чтобы это сделать, необходимо добавить скрипт, который будет содавать такое окружение.
В простейшем случае достаточно сделать symlink:
```bash
ln -s common/scripts/create-virtual-environment
```

Создаем virtual environment:
```bash
./create-virtual-environment
```

Скрипт всего лишь запускает с нужными параметрами
[mkdevelvirtualenv](https://github.com/KonishchevDmitry/mkdevelvirtualenv),
который в свою очередь использует
[pyenv-virtualenvwrapper](https://github.com/pyenv/pyenv-virtualenvwrapper) для создания виртуального
окружения с последующей возможностью удобного переключения между проектами.

Теперь, когда окружение создано, достаточно в любой момент времени выполнить команду
`workon $project_name`, которая перенесет вас в директорию с проектом и активирует созданное
окружение.

## Создание собственного стенда средствами Vagrant

Если проект очень простой, то для комфортной работы с ним во время разработки вполне достаточно
виртуального окружения, создание которого описано выше, но если проект завистит от какого-то
системного окружения (базы данных, других компонент), либо и вовсе в силу своих особенностей может
работать только под Linux, а у разработчика - MacOS, то гораздо удобнее разрабатываться не
непосредственно на своем ноутбуке, а иметь возможность в любой момент времени запустить на своем
ноутбуке вируальную машину, в которой автоматически будет настроено все необходимое окружение -
которое в любой момент можно пересоздать, если в новой версии проекта это окружение должно быть
другим. Да и в целом нерационально тратить время каждого разработчика на настройку собственного
стенда - гораздо эффективнее предоставить механизм для быстрого развертывания стенда с нуля,
которым сможет воспользоваться каждый разработчик.

Для этих целей у нас служит [Vagrant](https://www.vagrantup.com/). В репозиторий проекта
добавляются конфигурационные файлы [Vagrant](https://www.vagrantup.com/) +
[Ansible](https://www.ansible.com/), которые позволяют с помощью одной команды `vagrant up`
получить полностью работающий стенд для конкретного проекта, тем самым сильно уменьшая порог
входа в проект для новых разработчиков.

Vagrant-окружение строится на базе
[ansible-vagrant](https://github.com/KonishchevDmitry/ansible-vagrant) (набор базовых
конфигурационных файлов и скриптов, которые необходимы каждому проекту), который подключается
к проекту в виде сабмодуля.


## Работа с проектом в процессе разработки

Суммируя все сказанное выше, можно привести список следующих шагов, которые необходимо
выполнить перед работой над проектом, чтобы получить удобное окружение для разработки:

Клонируем репозиторий вместе со всеми сабмодулями:
```
$ git clone ssh://git@bb.yandex-team.ru/cloud/$project_name.git
$ cd $project_name
$ git submodule update --init --recursive
```

Создаем virtual environment для разработки (требует установленного
[pyenv-virtualenvwrapper](https://github.com/pyenv/pyenv-virtualenvwrapper)):
```bash
./create-virtual-environment
```
Далее необходимо в настройках PyCharm установить это окружение для проекта - в таком случае
PyCharm будет знать обо всех установленных для проекта зависимостях, а также ориентироваться
между проектами, подключенными в качестве сабмодулей в головной проект.

Активировать виртуальное окружение можно командой `workon $project_name`.

Если для проекта настроено Vagrant-окружение, необходимо установить
[VirtualBox](https://www.virtualbox.org/) + [Vagrant](https://www.vagrantup.com/).

!!!ВНИМАНИЕ: Следующий шаг нужно исполнять в тот момент, когда в VirtualBox погашены все машины и закрыт GUI. Этот шаг достаточно исполнить единожды.
Для настройки IPv6 внутри виртуальных машин нужно внутри активного виртуального окружения дернуть следующие команды:
```
VBoxManage natnetwork add --netname yc-ipv6-nat --network [2a02:6b8:0:408::] --ipv6 on
./provisioning/files/advertise_default_ipv6_route.py --natnetwork yc-ipv6-nat
```

В Linux также необходимо иметь следующую переменную окружения, чтобы сообщить Vagrant, что
виртуальная машина должна запускаться средствами VirtualBox, а не libvirt:
```bash
export VAGRANT_DEFAULT_PROVIDER=virtualbox
```

В MacOS нужно задать локаль, существующую в Ubuntu 16.04, например в .bash_profile добавить
```bash
export LC_ALL=en_US.UTF-8
```

Далее с помощью команды `workon $project_name` переходим в виртуальное окружение проекта
(оно нам нужно, т. к. в нем будет установлен Ansible, который нужен для provisioning'а
виртуальной машины) и запускаем команду `vagrant up`.

Сообщений вида `FAILED - RETRYING: $some_description ($number retries left)` пугаться не
стоит - это следствие того, что в Ansible нет встроенных стредств для распараллеливания
задач, поэтому приходится пользоваться различными хаками, которые и генерируют данные
сообщения.

Если `vagrant up` сфейлится, то повторить процедуру provisioning'а можно командой
`vagrant provision` (при последующем запуске `vagrant up` будет исходить из предположения,
что provisioning завершился успешно).

Далее добавляем в `~/.bashrc` следующий alias:
```bash
alias vagrant-ssh-tmux='vagrant ssh -- -t ". ~/.bashrc.d/vagrant-user.sh; tmux has-session 2>/dev/null || { unset SSH_AUTH_SOCK && tmux new-session -d; } && exec tmux attach-session"'
```
и выполняем команду `vagrant-ssh-tmux` - она зайдет на виртуальную машину по ssh и подключит нас
к предварительно созданной `tmux`'овой сесии, в которой будут запущены все наши сервисы.

Вся директория с проектом будет подмонтирована в виртуальной машине в `/vagrant`, что позволяет
редактировать код в PyCharm на ноутбуке и тут же проверять его работоспособность простым
перезапуском сервиса в `tmux`'овой сессии - без пересборки/выкатки пакетов и прочих рутинных
действий, которые замедляют разработку.


## Если хочется nested virtualization

Начиная с версии 6.1 VirtualBox начал поддерживать nested virtualization для процессоров Intel.
Но на январь 2020 года опакетированных версиях Vagrant поддержки VirtualBox 6.1 нет.
Для того, чтобы это преодолеть есть 2 сценария:
1) Поставить версию из мастера
2) Подредактировать фаылй так, как описано здесь: https://github.com/oracle/vagrant-boxes/issues/178
3) Дождаться релиза 2.2.7: https://github.com/hashicorp/vagrant/milestone/44
Включить nested virtualization для машины можно командой:
```bash
vagrant halt && VBoxManage modifyvm $(whoami)-compute-vagrant --nested-hw-virt on
```
После этого сразу становится активна эта [ветка](https://bb.yandex-team.ru/projects/CLOUD/repos/compute/browse/compute_node/yc_compute_node/vsock.py?until=9ac164a460be52504949a942c340b058b3ed5068&untilPath=compute_node%2Fyc_compute_node%2Fvsock.py#109):
и машины начинают требовать наличия /dev/vhost-vsock. Последнее ядро из апстримного репозитория 
не содержит этого модуля. Поэтому лучше установть наше YC ядро. Поскольку это модуль, его нужно
загружать. Так же нужны права на /dev/kvm, /dev/vhost-vsock. Всё это уже реализвано в [этой](https://bb.yandex-team.ru/projects/CLOUD/repos/compute/browse?at=refs%2Fheads%2FONLY_HETERO) ветке


## Сборка deb-пакетов

`Makefile` исходит из следующего предположения (при необходимости можно задать явно): все
директории, в которых есть файл `setup.py` - директории с Python-пакетами. Если в такой
директории присутствует директория `bin`, то это сервис.

Под каждый сервис создается свое виртуальное окружение, которое помещается в
`/usr/lib/yc/$name`, все `yc-*`-скрипты, из директории `bin` симлинкаются в `/usr/bin`.
Предполагается, что под каждый сервис также будет создан отдельный deb-пакет (но при этом
будет один deb-src-пакет на весь проект).

Директория `debian` заполняется по аналогии с другими сервисами.

Для тестовой сборки пакета можно выполнить команду `make deb`. Для production deb-пакеты
собираются в CI с помощью `sbuild`.
