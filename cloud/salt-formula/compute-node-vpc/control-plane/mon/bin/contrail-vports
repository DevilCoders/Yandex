#!/usr/bin/env python3
import argparse
import json
import os
import re
import subprocess
import time
from collections import namedtuple
from typing import List, Tuple, Optional

from yc_contrail_monitoring import load_str, parse_xml, parse_object_list, IntrospectionPorts
from yc_monitoring import report_status_and_exit, Status


RECHECK_PERIOD_SECONDS = 15  # Ignore interfaces in transition state, while information not yet received from control.
MAX_VPORT_INTERFACES = 200  # To catch possible leaks.


ItfSandeshData = namedtuple("ItfSandeshData", ["index", "name", "uuid", "vrf_name", "active", "type"])
ConnectionInfo = namedtuple("ConnectionInfo", ["name", "status"])


def load_itf_sandesh_data(debug_file: str) -> List[ItfSandeshData]:
    raw_str = load_str(IntrospectionPorts.VRouterAgent, "Snh_ItfReq", debug_file=debug_file)
    xml = parse_xml(raw_str)
    return parse_object_list(xml, ItfSandeshData, ".//ItfSandeshData")


def load_connection_infos() -> List[ConnectionInfo]:
    raw_str = load_str(IntrospectionPorts.VRouterAgent, "Snh_SandeshUVECacheReq?x=NodeStatus")
    xml = parse_xml(raw_str)
    return parse_object_list(xml, ConnectionInfo, ".//ConnectionInfo")


def parse_args():
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument("--file", metavar="FILE", help="read XML from file, don't make HTTP request")
    parser.add_argument("--dump", action="store_true")
    parser.add_argument("--instances-dir", metavar="DIR", default="/var/lib/yc/compute-node/instances")
    return parser.parse_args()


def get_affected_vports(args) -> Tuple[List[str], int]:
    problems = []
    count_vport_interfaces = 0

    for iface in load_itf_sandesh_data(debug_file=args.file):
        if args.dump:
            print(iface)

        if iface.type == "vport":
            count_vport_interfaces += 1
            if "ERROR" in iface.vrf_name:
                problems.append(iface.name)

    return sorted(problems), count_vport_interfaces


def get_control_nodes_info() -> str:
    details = []

    for info in load_connection_infos():
        if info.name and info.name.startswith("control-node"):
            details.append("{}:{}".format(info.name, info.status))

    return ", ".join(details)


def get_instances_list(args, problems: List[str]) -> List[str]:
    instances_ids = os.listdir(args.instances_dir)
    problem_instances = set()
    for instance_id in instances_ids:
        try:
            with open(os.path.join(args.instances_dir, instance_id, "state.json")) as state:
                instance = json.loads(state.read())

            for i in range(len(instance.get("network_interfaces", []))):
                iface_id = "-{}".format(i)
                suffix_len = 14 - 3 - len(iface_id)
                iid = instance_id[3:]
                iface_suffix = iid[:suffix_len] + iface_id
                if args.dump:
                    print(iface_suffix)

                if "tap" + iface_suffix in problems or "qvb" + iface_suffix in problems:
                    problem_instances.add(instance_id)

        except Exception as e:
            # Can't load state.json, ignore
            if args.dump:
                print(e)
            pass

    return list(problem_instances)


def main():
    args = parse_args()

    affected_vports, count_vport_interfaces = get_affected_vports(args)
    if affected_vports and not args.file:
        time.sleep(RECHECK_PERIOD_SECONDS)
        affected_vports_rechecked, count_vport_interfaces = get_affected_vports(args)
        affected_vports = sorted(set.intersection(set(affected_vports), set(affected_vports_rechecked)))

    if affected_vports:
        message = "{} of {} vports are affected: {}.".format(len(affected_vports), count_vport_interfaces,
                                                         ", ".join(affected_vports))
        affected_instances = get_instances_list(args, affected_vports)
        if affected_instances:
            message += " {} affected instances: {}.".format(len(affected_instances), ", ".join(affected_instances))
            status = Status.CRIT
        else:
            message += " No instances affected."
            status = Status.WARN
        if not args.file:
            message += " {}.".format(get_control_nodes_info())
        message += " Check CLOUD-11694 (vrf 65535)."
        report_status_and_exit(status, message)

    if count_vport_interfaces > MAX_VPORT_INTERFACES:
        report_status_and_exit(Status.WARN, "WARN, too many vport interfaces: {}. Leak?".format(count_vport_interfaces))

    report_status_and_exit(Status.OK, "OK, {} vport interfaces.".format(count_vport_interfaces))


if __name__ == "__main__":
    main()
