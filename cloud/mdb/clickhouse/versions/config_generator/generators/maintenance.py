import glob
import os.path
from typing import List

from jinja2 import Environment

from cloud.mdb.clickhouse.versions.config_generator.utils import Config, dump_yaml, load_yaml_file
from cloud.mdb.clickhouse.versions.lib.version import Version, VersionsConfig

CONFIGS_PATH = '../../mdb-maintenance/configs/'

MINOR_UPDATE_CONFIG = """
# Generated by "make generate" from cloud/mdb/clickhouse/versions
info: Minor update of ClickHouse version to {{ version }}
repeatable: true
supports_offline: true
clusters_selection:
  db: >-
    WITH clusters AS (
        SELECT
            c.cid,
            CAST(string_to_array(p.value #>> '{data,clickhouse,ch_version}', '.') AS int[]) AS version_nums
         FROM dbaas.subclusters sc
         JOIN dbaas.clusters c USING(cid)
         JOIN dbaas.pillar p USING(subcid)
        WHERE c.status IN ('RUNNING', 'STOPPED')
          AND sc.roles && '{clickhouse_cluster}'
          AND CAST(p.value #>> '{data,clickhouse,unmanaged,minor_updates_disabled}' AS bool) IS DISTINCT FROM true
{%- if vtypes %}
          AND EXISTS (SELECT 1
                      FROM dbaas.hosts h
                      JOIN dbaas.flavors f ON (f.id = h.flavor)
                      WHERE subcid = h.subcid AND vtype = ANY(CAST('{{ vtypes }}' AS dbaas.virt_type[])))
{%- endif %}
{%- if envs %}
          AND c.env = ANY(CAST('{{ envs }}' AS dbaas.env_type[]))
{%- endif %}
    )
    SELECT c.cid
      FROM clusters c
     WHERE c.version_nums > ARRAY[{{ ', '.join(version_numbers[:2]) }}]
       AND c.version_nums < ARRAY[{{ ', '.join(version_numbers) }}]
pillar_change: >-
  UPDATE dbaas.pillar p
     SET value = jsonb_set(value, '{data,clickhouse,ch_version}', to_jsonb(CAST('{{ version }}' AS text)))
    FROM dbaas.subclusters sc
   WHERE p.subcid=sc.subcid
     AND sc.cid=:cid
     AND sc.roles && '{clickhouse_cluster}'
worker:
  operation_type: clickhouse_cluster_modify
  task_type: clickhouse_cluster_maintenance
  task_args_query: >-
    SELECT
        jsonb_build_object(
            'restart', true,
            'version_from', p.value #>> '{data,clickhouse,ch_version}',
            'version_to', '{{ version }}'
        )
      FROM dbaas.clusters c
      JOIN dbaas.subclusters sc USING (cid)
      JOIN dbaas.pillar p USING (subcid)
     WHERE sc.roles && '{clickhouse_cluster}'
       AND c.cid = :cid
  timeout_query: >-
    SELECT
      CONCAT(
        CASE
          WHEN count(*) < 16
            THEN floor(log(2, count(*))) + 1
            ELSE floor((count(*) + 34) / 10)
          END * 2,
        'h')
      FROM dbaas.shards s
      JOIN dbaas.subclusters sc
      USING (subcid)
    WHERE sc.cid = :cid
      AND sc.roles && '{clickhouse_cluster}'
max_delay_days: 21
min_days: 7
""".strip()

MAJOR_UPDATE_CONFIG = """
# Generated by "make generate" from cloud/mdb/clickhouse/versions
info: Major update of deprecated ClickHouse version {{ from_version_name }} to {{ to_version_name }}
repeatable: true
supports_offline: true
clusters_selection:
  db: >-
    WITH clusters AS (
        SELECT
            c.cid,
            CAST(string_to_array(p.value #>> '{data,clickhouse,ch_version}', '.') AS int[]) AS version_nums
         FROM dbaas.subclusters sc
         JOIN dbaas.clusters c USING(cid)
         JOIN dbaas.pillar p USING(subcid)
        WHERE c.status IN ('RUNNING', 'STOPPED')
          AND sc.roles && '{clickhouse_cluster}'
          AND CAST(p.value #>> '{data,clickhouse,unmanaged,major_updates_disabled}' AS bool) IS DISTINCT FROM true
{%- if vtypes %}
          AND EXISTS (SELECT 1
                      FROM dbaas.hosts h
                      JOIN dbaas.flavors f ON (f.id = h.flavor)
                      WHERE subcid = h.subcid AND vtype = ANY(CAST('{{ vtypes }}' AS dbaas.virt_type[])))
{%- endif %}
{%- if envs %}
          AND c.env = ANY(CAST('{{ envs }}' AS dbaas.env_type[]))
{%- endif %}
    )
    SELECT c.cid
      FROM clusters c
     WHERE c.version_nums[1::2] = ARRAY[{{ ', '.join(from_version_numbers[:2]) }}]
pillar_change: >-
  UPDATE dbaas.pillar p
     SET value = jsonb_set(value, '{data,clickhouse,ch_version}', to_jsonb(CAST('{{ to_version }}' AS text)))
    FROM dbaas.subclusters sc
   WHERE p.subcid=sc.subcid
     AND sc.cid=:cid
     AND sc.roles && '{clickhouse_cluster}'
worker:
  operation_type: clickhouse_cluster_modify
  task_type: clickhouse_cluster_maintenance
  task_args_query: >-
    SELECT
        jsonb_build_object(
            'restart', true,
            'version_from', p.value #>> '{data,clickhouse,ch_version}',
            'version_to', '{{ to_version }}'
        )
      FROM dbaas.clusters c
      JOIN dbaas.subclusters sc USING (cid)
      JOIN dbaas.pillar p USING (subcid)
     WHERE sc.roles && '{clickhouse_cluster}'
       AND c.cid = :cid
  timeout_query: >-
    SELECT
      CONCAT(
        CASE
          WHEN count(*) < 16
            THEN floor(log(2, count(*))) + 1
            ELSE floor((count(*) + 34) / 10)
          END * 2,
        'h')
      FROM dbaas.shards s
      JOIN dbaas.subclusters sc
      USING (subcid)
    WHERE sc.cid = :cid
      AND sc.roles && '{clickhouse_cluster}'
max_delay_days: 21
min_days: 7
""".strip()


def maintenance_config_generator(versions_config: VersionsConfig) -> List[Config]:
    generators = [
        generate_minor_update_config,
        generate_disablement_of_old_minor_update_configs,
        generate_major_update_config,
    ]

    configs = []
    for generator in generators:
        for version in versions_config.versions:
            configs.extend(generator(versions_config, version))

    return configs


def generate_minor_update_config(_config: VersionsConfig, version_config: Version) -> List[Config]:
    automatic_minor_updates = version_config.automatic_minor_updates
    if not automatic_minor_updates.enabled:
        return []

    context = {}
    add_version_to_context(context, version_config)
    add_list_to_context(context, 'envs', automatic_minor_updates.cluster_environments)
    add_list_to_context(context, 'vtypes', automatic_minor_updates.vtypes)

    file_path = generate_file_path('clickhouse_update_minor', context['version_numbers'][:2])

    template = Environment().from_string(MINOR_UPDATE_CONFIG)
    config = template.render(context)

    return [Config(file_path, config)]


def generate_disablement_of_old_minor_update_configs(_config: VersionsConfig, version_config: Version) -> List[Config]:
    automatic_minor_updates = version_config.automatic_minor_updates
    if not automatic_minor_updates.cancel_planned_updates_to_previous_versions:
        return []

    result = []
    version_numbers = version_config.version.split('.')
    path_pattern = generate_file_path('clickhouse_update_minor', version_numbers[:2] + ['*'])
    ignored_path = generate_file_path('clickhouse_update_minor', version_numbers[:3])
    for path in glob.glob(path_pattern):
        if path == ignored_path:
            continue

        config = load_yaml_file(path)
        config['disabled'] = True

        result.append(Config(path, dump_yaml(config)))

    return result


def generate_major_update_config(config: VersionsConfig, version_config: Version) -> List[Config]:
    automatic_major_updates = version_config.automatic_major_updates
    if not automatic_major_updates.enabled:
        return []

    to_version_config = config.get_version(automatic_major_updates.target)

    context = {}
    add_version_to_context(context, version_config, 'from')
    add_version_to_context(context, to_version_config, 'to')
    add_list_to_context(context, 'envs', automatic_major_updates.cluster_environments)
    add_list_to_context(context, 'vtypes', automatic_major_updates.vtypes)

    file_path = generate_file_path('clickhouse_update_major', context['from_version_numbers'][:2])

    template = Environment().from_string(MAJOR_UPDATE_CONFIG)
    config = template.render(context)

    return [Config(file_path, config)]


def generate_file_path(prefix: str, version_numbers: List[str]) -> str:
    return os.path.join(CONFIGS_PATH, f'{prefix}_{"_".join(version_numbers)}.yaml')


def add_version_to_context(context: dict, version_config: Version, prefix: str = None) -> None:
    prefix = f'{prefix}_' if prefix else ''
    context.update(
        {
            f'{prefix}version': version_config.version,
            f'{prefix}version_name': version_config.name,
            f'{prefix}version_numbers': version_config.version.split('.'),
        }
    )


def add_list_to_context(context: dict, key: str, envs: List[str]) -> None:
    context[key] = f'{{{",".join(envs)}}}' if envs else None
