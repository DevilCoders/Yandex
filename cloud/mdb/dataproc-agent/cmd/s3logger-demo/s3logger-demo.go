// Simple command-line program that generates output and saves it to Yandex S3.
// It is created in order to test s3logger functionality.
package main

import (
	"context"
	"flag"
	"fmt"
	"math/rand"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"time"

	meta "a.yandex-team.ru/cloud/mdb/dataproc-agent/pkg/metaparser/http"
	"a.yandex-team.ru/cloud/mdb/dataproc-agent/pkg/s3logger"
	"a.yandex-team.ru/library/go/core/log"
	"a.yandex-team.ru/library/go/core/log/zap"
)

var mode string
var token string
var endpoint string
var region string
var bucket string
var chunkSize int
var maxPoolSize int
var syncInterval int
var outputRate int
var outputSize int

func main() {
	rand.Seed(time.Now().UnixNano())
	parseOptions()
	if mode == "uploader" {
		validate()
		saver := createS3Logger()
		startLogGenerator(saver)
		ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
		_ = saver.Close(ctx)
		cancel()
	} else {
		generateOutput()
	}
}

func parseOptions() {
	flag.StringVar(&mode, "mode", "uploader", "Mode: uploader (default) or generator")
	flag.StringVar(&token, "token", "", "IAM token")
	flag.StringVar(&endpoint, "endpoint", "https://storage.yandexcloud.net", "Yandex S3 endpoint")
	flag.StringVar(&region, "region", "ru-central1", "Yandex cloud region name")
	flag.StringVar(&bucket, "bucket", "", "Bucket name")
	flag.IntVar(&chunkSize, "chunk-size", 4*1024, "Chunk size in bytes")
	flag.IntVar(&maxPoolSize, "max-pool-size", 1024*1024, "Maximum pool size in bytes")
	flag.IntVar(&syncInterval, "sync-interval", 2, "Sync interval in seconds")
	flag.IntVar(&outputRate, "output-rate", 1024, "How many bytes per second are generated")
	flag.IntVar(&outputSize, "output-size", 8*1024, "Total number of generated bytes")
	flag.Parse()
}

func validate() {
	if bucket == "" {
		fmt.Printf("Please specify bucket name\n")
		os.Exit(1)
	}

	if token == "" {
		fmt.Printf("Token is not provided. Will try to get token from metadata server.\n")
		var err error
		token, err = tokenFromMetadataServer()
		if err != nil {
			fmt.Printf("Failed to load token from metadata server: %s\n", err)
			os.Exit(1)
		}
	}
}

func createS3Logger() *s3logger.PipeProcessor {
	logger, err := zap.New(zap.KVConfig(log.DebugLevel))
	if err != nil {
		fmt.Printf("failed to initialize logger: %s\n", err)
		os.Exit(1)
	}

	jobID := randSeq(10)
	filename := fmt.Sprintf("jobs/%s/%s", jobID, "driveroutput.%d")
	fmt.Printf("Output is saved to: s3a://%s/jobs/%s/driveroutput.0\n", bucket, jobID)

	config := s3logger.Config{
		Endpoint:      endpoint,
		RegionName:    region,
		BucketName:    bucket,
		ChunkSize:     chunkSize,
		MaxPoolSize:   maxPoolSize,
		SyncInterval:  time.Duration(syncInterval) * time.Second,
		UploadTimeout: time.Second * 5,
	}

	tokenProvider := func() string {
		return token
	}
	saver, err := s3logger.New(config, tokenProvider, logger, filename)
	if err != nil {
		logger.Errorf("Failed to create s3 output saver: %s", err)
		os.Exit(1)
	}

	return saver
}

func generateOutput() {
	streams := []*os.File{os.Stdout, os.Stderr}
	lineSize := 64
	pattern := strings.Repeat("long-", 10) + "line %08d\n" // 64 bytes
	linesPerSecond := outputRate / lineSize
	delay := 1000 / linesPerSecond
	outputLines := outputSize / lineSize
	for i := 0; i < outputLines; i += 1 {
		_, _ = fmt.Fprintf(streams[i%2], pattern, i)
		time.Sleep(time.Duration(delay) * time.Millisecond)
	}
}

func startLogGenerator(saver *s3logger.PipeProcessor) {
	cmd := exec.Command("./s3logger-demo",
		"-mode", "generator",
		"-output-rate", strconv.Itoa(outputRate),
		"-output-size", strconv.Itoa(outputSize),
	)
	stdout, _ := cmd.StdoutPipe()
	cmd.Stderr = cmd.Stdout

	err := cmd.Start()
	if err != nil {
		fmt.Printf("Subprocess command has failed: %s\n", err)
		fmt.Printf("Exit code: %d\n", cmd.ProcessState.ExitCode())
		os.Exit(1)
	}
	_, err = saver.ReadFrom(stdout)
	if err != nil {
		fmt.Printf("Failed to werite logs: %s\n", err)
	}
	_ = cmd.Wait()

}

func tokenFromMetadataServer() (token string, err error) {
	config := meta.DefaultConfig()
	metaGetter := meta.New(config)
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()

	metadata, err := metaGetter.GetComputeMetadata(ctx)
	if err != nil {
		return "", err
	}
	return metadata.IAMToken, nil
}

var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")

func randSeq(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}
