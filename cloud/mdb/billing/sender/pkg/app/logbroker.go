package app

import (
	"context"
	"fmt"
	"os"

	"a.yandex-team.ru/cloud/mdb/billing/internal/billingdb"
	bdbpg "a.yandex-team.ru/cloud/mdb/billing/internal/billingdb/pg"
	"a.yandex-team.ru/cloud/mdb/billing/sender/internal/sender"
	"a.yandex-team.ru/cloud/mdb/billing/sender/internal/writer/logbroker"
	"a.yandex-team.ru/cloud/mdb/internal/app"
	logbrokerWriter "a.yandex-team.ru/cloud/mdb/internal/logbroker/writer/logbroker"
	"a.yandex-team.ru/cloud/mdb/internal/ready"
	"a.yandex-team.ru/library/go/core/log"
	"a.yandex-team.ru/library/go/core/xerrors"
)

const (
	DefaultShard = "shard01"
)

type LogBrokerAppConfig struct {
	Config    `yaml:",inline"`
	LogBroker logbrokerWriter.Config `json:"logbroker" yaml:"logbroker"`
}

var _ app.AppConfig = &LogBrokerAppConfig{}

func DefaultLogBrokerAppConfig() LogBrokerAppConfig {
	return LogBrokerAppConfig{Config: DefaultConfig()}
}

type LogBrokerSenderApp struct {
	SenderApp
	Config LogBrokerAppConfig
}

func NewLBMetricsSenderAppFromConfig(ctx context.Context, btype billingdb.BillType) (*LogBrokerSenderApp, error) {
	conf := DefaultLogBrokerAppConfig()
	opts := app.DefaultToolOptions(&conf, fmt.Sprintf("%s.yaml", AppName))
	opts = append(opts, app.WithMetrics())
	opts = append(opts, app.WithMetricsSendOnShutdown())

	baseApp, err := app.New(opts...)
	if err != nil {
		return nil, xerrors.Errorf("make base app, %w", err)
	}
	logger := baseApp.L()

	if !conf.Billingdb.Password.FromEnv("BILLINGDB_PASSWORD") {
		logger.Info("BILLINGDB_PASSWORD is empty")
	}

	bdb, err := bdbpg.New(conf.Billingdb, log.With(logger, log.String("cluster", bdbpg.DBName)))
	if err != nil {
		return nil, xerrors.Errorf("prepare BillingDB endpoint: %w", err)
	}

	a := &LogBrokerSenderApp{
		SenderApp: SenderApp{
			App: baseApp,
			BDB: bdb,
		},
		Config: conf,
	}
	// We send all btype stuff into one message group (and use one sourceID = bill_type:default_shard) for now
	// If someday we have to add another shards, we will be able to do it this way:
	// - add enum 'shard' to billing.metrics_queue as a column (with current default shard as default value)
	// - initialize here a bunch of lb-clients with source_id based on possible enum values
	//   map[shardID]logbroker.Impl(source_id = bill_type:shardID)
	// - pass this map into sender and use corresponding lb-client for selected batch

	lbSourceID := fmt.Sprintf("%s:%s", btype, DefaultShard)
	if a.Config.LogBroker.SourceID != "" {
		return nil, xerrors.Errorf("unexpected logbroker.source_id = %s, value is autogenerated from bill_type:shard and will be '%s'", err, lbSourceID)
	}
	a.Config.LogBroker.SourceID = lbSourceID

	lbwriter, err := logbroker.New(ctx, a.Config.LogBroker, a.L())
	if err != nil {
		return nil, xerrors.Errorf("LogBroker initialization failed: %w", err)
	}

	a.Sender = sender.New(btype, a.BDB, sender.FetchAndSendBatch, lbwriter, a.L(), a.Config.Sender)
	if err = ready.Wait(ctx, a.Sender, &ready.DefaultErrorTester{Name: "databases", L: a.L()}, a.Config.InitTimeout.Duration); err != nil {
		return nil, xerrors.Errorf("wait backend: %w", err)
	}
	return a, err
}

func RunLBBillingMetricsSender(ctx context.Context, btype billingdb.BillType) int {
	a, err := NewLBMetricsSenderAppFromConfig(ctx, btype)
	if err != nil {
		fmt.Fprintf(os.Stderr, "sender failed to start app: %+v\n", err)
		return 1
	}

	a.L().Infof("Sender started to report billing metrics")
	defer a.App.Shutdown()

	if err := a.Sender.Serve(ctx); err != nil {
		a.L().Error("Failed to send billing metrics", log.Error(err))
		return 11
	}

	a.L().Infof("Sender has sent metrics successfully")
	return 0
}
