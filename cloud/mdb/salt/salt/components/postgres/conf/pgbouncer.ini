{% from "components/postgres/pg.jinja" import pg with context %}
{% if bouncer is defined %}
{% set bouncer="%02d"|format(bouncer|int) -%}
{% endif %}
{% if internal_bouncer is defined %}
{% set internal_bouncer="%02d"|format(internal_bouncer|int) -%}
{% endif %}
;; database name = connect string
;;
;; connect string params:
;;   dbname= host= port= user= password=
;;   client_encoding= datestyle= timezone=
;;   pool_size= connect_query=
[databases]
{% if bouncer is defined %}
{% set dbhost = 'localhost port=7432' %}
{% else %}
{% set dbhost = 'localhost' %}
{% endif %}
{% if salt['pillar.get']('data:config:pgbouncer_redirect', False) %}
{% if salt['grains.get']('pg') and 'role' in salt['grains.get']('pg').keys() and salt['grains.get']('pg')['role'] == 'replica' %}
{% set dbhost = salt['grains.get']('pg')['master'] + ' port=6432' %}
{% endif %}
{% endif %}
{% set overrides = salt['pillar.get']('data:config:pgbouncer:override_pool_mode', {}) %}
{% set default_pool_mode = salt['pillar.get']('data:config:pool_mode', 'transaction') %}
{% for db in overrides.keys()|sort %}
{% if overrides.get(db, default_pool_mode) != default_pool_mode %}
{{ db }} = host={{ dbhost }} pool_mode={{ overrides.get(db) }}
{% endif %}
{% endfor %}
* = host={{ dbhost }}
{% set unmanaged_dbs = salt['pillar.get']('data:unmanaged_dbs', {"template1":{}}) %}
{% if unmanaged_dbs|length > 0 and pg.use_1c %}
template1 = host={{ dbhost }} dbname={{ unmanaged_dbs[0].keys()|first }}
{% endif %}

; foodb over unix socket
;foodb =

; redirect bardb to bazdb on localhost
;bardb = host=localhost dbname=bazdb

; access to dest database will go with single user
;forcedb = host=127.0.0.1 port=300 user=baz password=foo client_encoding=UNICODE datestyle=ISO connect_query='SELECT 1'

; use custom pool sizes
;nondefaultdb = pool_size=50 reserve_pool_size=10

; fallback connect string
;* = host=testserver

;; Configuration section
[pgbouncer]

;;;
;;; Administrative settings
;;;

{% if bouncer is defined %}
logfile = /var/log/postgresql/pgbouncer{{ bouncer }}.log
pidfile = /var/run/postgresql/pgbouncer{{ bouncer }}.pid
{% elif internal_bouncer is defined %}
logfile = /var/log/postgresql/pgbouncer_internal{{ internal_bouncer }}.log
pidfile = /var/run/postgresql/pgbouncer_internal{{ internal_bouncer }}.pid
{% else %}
logfile = /var/log/postgresql/pgbouncer.log
pidfile = /var/run/postgresql/pgbouncer.pid
{% endif %}

;;;
;;; Where to wait for clients
;;;

; ip address or * which means all ip-s
{% if internal_bouncer is defined %}
listen_addr = localhost
listen_port = 7432
{% else %}
listen_addr = *
listen_port = 6432
{% endif %}

; unix socket is also used for -R.
; On debian it should be /var/run/postgresql
{% if bouncer is defined %}
unix_socket_dir = /var/run/pgbouncer{{ bouncer }}
{% elif internal_bouncer is defined %}
unix_socket_dir = /var/run/pgbouncer_internal{{ internal_bouncer }}
{% else %}
;unix_socket_dir = /tmp
{% endif %}
;unix_socket_mode = 0777
;unix_socket_group =

;;;
;;; Authentication settings
;;;

; any, trust, plain, crypt, md5
auth_type = {{ salt['pillar.get']('data:config:auth_type', 'md5') }}
;auth_file = /8.0/main/global/pg_auth
auth_file = /etc/pgbouncer/userlist.txt

;; Query to use to fetch password from database.  Result
;; must have 2 columns - username and password hash.
;auth_query = SELECT usename, passwd FROM pg_shadow WHERE usename=$1

;;;
;;; Users allowed into database 'pgbouncer'
;;;

; comma-separated list of users, who are allowed to change settings
admin_users = postgres

; comma-separated list of users who are just allowed to use SHOW command
stats_users = monitor, postgres

;;;
;;; Pooler personality questions
;;;

; When server connection is released back to pool:
;   session      - after client disconnects
;   transaction  - after transaction finishes
;   statement    - after statement finishes
{% if bouncer is defined %}
pool_mode = session
{% else %}
pool_mode = {{ default_pool_mode }}
{% endif %}

;
; Query for cleaning connection immediately after releasing from client.
; No need to put ROLLBACK here, pgbouncer does not reuse connections
; where transaction is left open.
;
; Query for 8.3+:
;   DISCARD ALL;
;
; Older versions:
;   RESET ALL; SET SESSION AUTHORIZATION DEFAULT
;
; Empty if transaction pooling is in use.
;
server_reset_query = {{ salt['pillar.get']('data:config:server_reset_query', 'DISCARD ALL;') }}


; Whether server_reset_query should run in all pooling modes.
; If it is off, server_reset_query is used only for session-pooling.
server_reset_query_always = {{ salt['pillar.get']('data:config:server_reset_query_always', '0') }}

;
; Comma-separated list of parameters to ignore when given
; in startup packet.  Newer JDBC versions require the
; extra_float_digits here.
;
ignore_startup_parameters = search_path,extra_float_digits,ssl_renegotiation_limit

;
; When taking idle server into use, this query is ran first.
;   SELECT 1
;
;server_check_query = select 1

; If server was used more recently that this many seconds ago,
; skip the check query.  Value 0 may or may not run in immediately.
server_check_delay = {{ salt['pillar.get']('data:config:server_check_delay', '30') }}

;; Use <appname - host> as application_name on server.
application_name_add_host = {{ salt['pillar.get']('data:config:application_name_add_host', '1') }}

;;;
;;; Connection limits
;;;

; total number of clients that can connect
max_client_conn = {{ salt['pillar.get']('data:config:max_client_conn', '20000') }}

{% set external_bouncers_count = salt['pillar.get']('data:pgbouncer:count', 1) %}
{% set internal_bouncers_count = salt['pillar.get']('data:pgbouncer:internal_count', 1) %}
{% set max_client_pool_conn = salt['pillar.get']('data:config:max_client_pool_conn', 4000) %}
{% if bouncer is defined %}
{% set max_client_pool_conn = (salt['pillar.get']('data:config:max_client_pool_conn', 4000)/ external_bouncers_count)|int %}
{% elif internal_bouncer is defined %}
{% set max_client_pool_conn = (salt['pillar.get']('data:config:max_client_pool_conn', 4000) / internal_bouncers_count)|int %}
{% endif %}
max_client_pool_conn = {{ max_client_pool_conn }}

; default pool size.  20 is good number when transaction pooling
; is in use, in session pooling it needs to be the number of
; max clients you want to handle at any moment
default_pool_size = {{ max_client_pool_conn }}

;; Minimum number of server connections to keep in pool.
min_pool_size = {{ salt['pillar.get']('data:config:min_pool_size', '0') }}

; how many additional connection to allow in case of trouble
;reserve_pool_size = 5

; if a clients needs to wait more than this many seconds, use reserve pool
;reserve_pool_timeout = 3

; how many total connections to a single database to allow from all pools
;max_db_connections = 50
;max_user_connections = 50

; If off, then server connections are reused in LIFO manner
;server_round_robin = 0

;;;
;;; Logging
;;;

;; Syslog settings
;syslog = 0
;syslog_facility = daemon
;syslog_ident = pgbouncer

{% if internal_bouncer is defined %}
; log if client connects or server connection is made
log_connections = {{ salt['pillar.get']('data:pgbouncer:internal_log_connections', '0') }}

; log if and why connection was closed
log_disconnections = {{ salt['pillar.get']('data:pgbouncer:internal_log_disconnections', '0') }}

; log error messages pooler sends to clients
log_pooler_errors = {{ salt['pillar.get']('data:pgbouncer:internal_log_pooler_errors', '1') }}
{% else %}
; log if client connects or server connection is made
log_connections = {{ salt['pillar.get']('data:pgbouncer:log_connections', '1') }}

; log if and why connection was closed
log_disconnections = {{ salt['pillar.get']('data:pgbouncer:log_disconnections', '1') }}

; log error messages pooler sends to clients
log_pooler_errors = {{ salt['pillar.get']('data:pgbouncer:log_pooler_errors', '1') }}
{% endif %}

;; Period for writing aggregated stats into log.
;stats_period = 60

;; Logging verbosity.  Same as -v switch on command line.
;verbose=0

;;;
;;; Timeouts
;;;

;; Close server connection if its been connected longer.
server_lifetime = {{ salt['pillar.get']('data:config:server_lifetime', '3600') }}

;; Close server connection if its not been used in this time.
;; Allows to clean unnecessary connections from pool after peak.
server_idle_timeout = {{ salt['pillar.get']('data:config:server_idle_timeout', '20') }}

;; Cancel connection attempt if server does not answer takes longer.
server_connect_timeout = {{ salt['pillar.get']('data:config:server_connect_timeout', '3') }}

;; If server login failed (server_connect_timeout or auth failure)
;; then wait this many second.
server_login_retry = {{ salt['pillar.get']('data:pgbouncer:server_login_retry', '1') }}

;; Dangerous.  Server connection is closed if query does not return
;; in this time.  Should be used to survive network problems,
;; _not_ as statement_timeout. (default: 0)
;query_timeout = 0

;; Dangerous.  Client connection is closed if the query is not assigned
;; to a server in this time.  Should be used to limit the number of queued
;; queries in case of a database or network failure. (default: 120)
query_wait_timeout = {{ salt['pillar.get']('data:pgbouncer:query_wait_timeout', '1') }}

;; Dangerous.  Client connection is closed if no activity in this time.
;; Should be used to survive network problems. (default: 0)
;client_idle_timeout = 0

;; Disconnect clients who have not managed to log in after connecting
;; in this many seconds.
client_login_timeout = {{ salt['pillar.get']('data:pgbouncer:client_login_timeout', '5') }}

;; Clean automatically created database entries (via "*") if they
;; stay unused in this many seconds.
; autodb_idle_timeout = 3600

;; How long SUSPEND/-R waits for buffer flush before closing connection.
;suspend_timeout = 10

;; Close connections which are in "IDLE in transaction" state longer than
;; this many seconds.
;idle_transaction_timeout = 0

;;;
;;; Low-level tuning options
;;;

;; buffer for streaming packets
;pkt_buf = 4096

;; man 2 listen
;listen_backlog = 128

;; Max number pkt_buf to process in one event loop.
;sbuf_loopcnt = 5

;; Maximum Postgres protocol packet size.
;max_packet_size = 2147483647

{% if bouncer is defined or internal_bouncer is defined %}
listen_reuseport = 1
{% endif %}
;; networking options, for info: man 7 tcp

;; Linux: notify program about new connection only if there
;; is also data received.  (Seconds to wait.)
;; On Linux the default is 45, on other OS'es 0.
;tcp_defer_accept = 0

;; In-kernel buffer size (Linux default: 4096)
;tcp_socket_buffer = 0

;; whether tcp keepalive should be turned on (0/1)
tcp_keepalive = 1

;; following options are Linux-specific.
;; they also require tcp_keepalive=1

;; count of keepaliva packets
tcp_keepcnt = 3

;; how long the connection can be idle,
;; before sending keepalive packets
tcp_keepidle = 15

;; The time between individual keepalive probes.
tcp_keepintvl = 5

;; DNS lookup caching time
;dns_max_ttl = 15

;; DNS zone SOA lookup period
;dns_zone_check_period = 0

;; DNS negative result caching time
;dns_nxdomain_ttl = 15

;;;
;;; Random stuff
;;;

;; Hackish security feature.  Helps against SQL-injection - when PQexec is disabled,
;; multi-statement cannot be made.
;disable_pqexec=0

;; Config file to use for next RELOAD/SIGHUP.
;; By default contains config file from command line.
;conffile

;; Win32 service name to register as.  job_name is alias for service_name,
;; used by some Skytools scripts.
;service_name = pgbouncer
;job_name = pgbouncer

;; Read additional config from the /etc/pgbouncer/pgbouncer-other.ini file
;%include /etc/pgbouncer/pgbouncer-other.ini

{% if salt['pillar.get']('data:pg_ssl', True) %}
{% if salt['pillar.get']('data:dbaas:vtype') == 'compute' and not salt['pillar.get']('data:dbaas:assign_public_ip', False) %}
{% set default_client_tls_sslmode = 'allow' %}
{% else %}
{% set default_client_tls_sslmode = 'require' %}
{% endif %}
{% if internal_bouncer is not defined %}
client_tls_sslmode = {{ salt['pillar.get']('data:pgbouncer:client_tls_sslmode', default_client_tls_sslmode) }}
client_tls_key_file = /etc/pgbouncer/ssl/server.key
client_tls_cert_file = /etc/pgbouncer/ssl/server.crt
client_tls_ca_file = /etc/pgbouncer/ssl/allCAs.pem
client_tls_protocols = tlsv1.2
{% if 'components.pg-dbs.pgmeta' in salt['pillar.get']('data:runlist', []) %}
server_tls_sslmode = {{ salt['pillar.get']('data:pgbouncer:server_tls_sslmode', 'allow') }}
server_tls_ca_file = /etc/pgbouncer/ssl/allCAs.pem
server_tls_protocols = tlsv1.2
{% endif %}
{% else %}
{% endif %}
{% endif %}

{% if salt['pillar.get']('data:pgbouncer:custom_user_pool', False) %}
[users]
{% for line in salt['pillar.get']('data:pgbouncer:custom_user_params', []) %}
{{ line }}
{% endfor %}
{% endif %}
