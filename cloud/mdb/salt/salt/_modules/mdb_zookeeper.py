# -*- coding: utf-8 -*-
"""
MDB ZooKeeper module.
"""

from __future__ import unicode_literals

import os
import string
from collections import OrderedDict
from itertools import chain
from random import SystemRandom
from hashlib import sha1
import base64

try:
    from salt.utils.stringutils import to_str
except ImportError:
    # salt library is not available in tests
    from cloud.mdb.salt_tests.common.arc_utils import to_str


__pillar__ = {}
__salt__ = {}


ZK_ACL_USER_SUPER = 'super'  # The same constant is in dbaas-internal-api


def __virtual__():
    return True


def load_config(config_path):
    """Load existing zoo.cfg"""
    result = {}
    if os.path.exists(config_path):
        with open(config_path) as f:
            for line in f.readlines():
                line = line.split('#', 1)[0]  # Allow comments
                if line.strip():
                    # DigestAuthenticationProvider.superDigest is base64 and contians symbols '='
                    key, value = [token.strip() for token in line.split('=', 1)]
                    result[key] = value
    return result


def _generate_password():
    """
    Generate random password for Java keystore.
    """
    symbols = string.ascii_letters + string.digits
    length = 20
    return ''.join([SystemRandom().choice(symbols) for _ in range(length)])


def _super_password_hash(user, password):
    """
    Make superDigest auth string.
    """
    hash = sha1('{user}:{password}'.format(user=user, password=password).encode('utf-8'))
    base64_hash = to_str(base64.b64encode(hash.digest()))
    return '{user}:{base64_hash}'.format(user=user, base64_hash=base64_hash)


def generate_config(config_old, params, nodes, zk_users):
    """
    Generate zoo.cfg configuration.
    config_old (dict): old config.
    params (dict): zookeeper params in the key-value form
    nodes (dict): fqdn -> id
    """

    def _generate_dynamic_section(zk_nodes, dynamic_params):
        section = {}
        for host, i in zk_nodes.items():
            server_entry = '{host}:2888:3888:participant;[::]:{client_port}'
            section['server.{}'.format(i)] = server_entry.format(
                host=host, client_port=dynamic_params.get('clientPort', 2181)
            )
        return section

    def _generate_static_section(zk_config):
        dynamic_keys = ['clientPort']
        dynamic = {key: zk_config[key] for key in dynamic_keys if key in zk_config}
        static = {key: value for key, value in zk_config.items() if key not in dynamic_keys}

        return static, dynamic

    static_section, dynamic_params = _generate_static_section(params)
    reconfig_enabled = static_section.get('reconfigEnabled', False)
    reconfig_enabled = str(reconfig_enabled).lower() in ['true', 'yes']

    if __salt__['pillar.get']('data:unmanaged:enable_zk_tls', False):
        password = ''

        if 'ssl.keyStore.password' in config_old:
            password = config_old['ssl.keyStore.password']
        else:
            password = _generate_password()
        static_section['ssl.keyStore.password'] = password
        static_section['ssl.quorum.keyStore.password'] = password

        if 'ssl.trustStore.password' in config_old:
            password = config_old['ssl.trustStore.password']
        else:
            password = _generate_password()
        static_section['ssl.trustStore.password'] = password
        static_section['ssl.quorum.trustStore.password'] = password

        if zk_users and (ZK_ACL_USER_SUPER in zk_users) and ('password' in zk_users[ZK_ACL_USER_SUPER]):
            super_password = zk_users[ZK_ACL_USER_SUPER]['password']
            hash = _super_password_hash(ZK_ACL_USER_SUPER, super_password)
            static_section['DigestAuthenticationProvider.superDigest'] = hash
            if ZK_ACL_USER_SUPER != 'super':
                static_section['zookeeper.superUser'] = ZK_ACL_USER_SUPER

    dynamic_section = {}
    if reconfig_enabled:
        # read from existing config to learn if the dynamic file
        # has already been generated by ZK
        if 'dynamicConfigFile' in config_old:
            dynamic_section['dynamicConfigFile'] = config_old['dynamicConfigFile']

    if not dynamic_section:
        dynamic_section = _generate_dynamic_section(nodes, dynamic_params)

    result = OrderedDict(chain(sorted(static_section.items()), sorted(dynamic_section.items())))

    return result


def compare_config(config_new, config_old):
    """Compare config to be generated with the existing one."""
    config_new = {key: str(value) for key, value in config_new.items()}
    set_new, set_old = set(config_new), set(config_old)
    intersect = set_new.intersection(set_old)

    added = set_new - intersect
    removed = set_old - intersect
    changed = set(o for o in intersect if config_old[o] != config_new[o])

    def hide_password(key, value):
        passwords = [
            'ssl.keyStore.password',
            'ssl.trustStore.password',
            'ssl.quorum.keyStore.password',
            'ssl.quorum.trustStore.password',
        ]
        return '<*password*>' if key in passwords else value

    diff = {}
    if added:
        diff['added'] = {k: hide_password(k, config_new[k]) for k in added}
    if removed:
        diff['removed'] = {k: hide_password(k, config_old[k]) for k in removed}
    if changed:
        diff['changed'] = {k: hide_password(k, config_new[k]) for k in changed}
    return diff


def render_config(config):
    """
    Render zoo.cfg configuration file.
    """
    result = ''
    for key, value in sorted(config.items()):
        result += '{}={}\n'.format(key, value)

    return result
