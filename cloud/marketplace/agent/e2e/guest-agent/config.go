// Config is so big only to have room in debugging, so one could change it without code modification.
// For example - test on existing instance and not on created one during tests.
// In ordinary e2e testing you should only pass token, folder, cloud and password.
// P.S. password after contrib acceptance will be autogenerated.
package e2e

import (
	"context"
	"path/filepath"
	"time"

	"github.com/heetch/confita"
	"github.com/heetch/confita/backend/env"
	"github.com/heetch/confita/backend/file"
)

// config holds config for instance, which we test, binary, which we upload and execute and winrm endpoint.
type config struct {
	Token       string `config:"e2e_token,required" yaml:"token"`
	CloudID     string `config:"e2e_cloud_id,required" yaml:"cloud_id"`
	FolderID    string `config:"e2e_folder_id,required" yaml:"folder_id"`
	InstancePWD string `config:"e2e_instance_pwd,required" yaml:"instance_pwd"`

	Source      string `config:"e2e_src_path" yaml:"src_path"`
	Destination string `config:"e2e_dst_path" yaml:"dst_path"`
}

const (
	configPath        = "config.yaml"
	configLoadTimeout = 10 * time.Second
	agentSrc          = "agent.exe"
	agentDest         = `c:\temp\agent.exe`
)

// loadConfig return instance of config we build form file and environment variables.
func loadConfig() (*config, error) {
	p, err := filepath.Abs(configPath)
	if err != nil {
		return nil, err
	}

	ctx, cancel := context.WithTimeout(context.Background(), configLoadTimeout)
	defer cancel()

	c := &config{
		Source:      agentSrc,
		Destination: agentDest,
	}
	l := confita.NewLoader(env.NewBackend(), file.NewOptionalBackend(p))
	err = l.Load(ctx, c)
	if err != nil {
		return nil, err
	}

	return c, nil
}
