===================
Bootstrap DB Scheme
===================



Repo Layout
-----------

Предлагается примерно следующая структура данного репозитория
::

    .
    ├── current  # все относящееся к текущей схеме
    │   ├── schema.dbm  # схема базы
    │   └── bootstrap.sql  # sql-файл для бустрапа схемы
    └── versions  # каталог с релизными версиями
        ├── 0.0.1  # первый релиз
        │   └── bootstrap.sql # sql-файл для бутстрапа схемы с нуля
        ├── 0.0.2  # второй релиз
        │   ├── bootstrap.sql # sql-файл для бустрапа схемы с нуля
        │   └── migrate-from-0.0.1.sql  # sql-файл для миграции с предыдущей версии
        ...


Редактирование схемы
--------------------

В настоящий момент мы используем утилиту **pgmodeler** для редактирования схемы базы. То есть первичным файлом
со схемой является *curreng/schema.dbm*, файл *current/bootstrap.sql* генерится из первого **pgmodeler**-ом.

Файл для миграции схемы пишем руками на основании сгенеренных *sql*-схем для старой и новой версии базы. Сейчас
нет инструментов для проверки того что *schema.v1 + migrate.from.v1.to.v2* дает такой же результат как
бутстраппинг *schema.v2*.


Деплой с изменением схемы базы
------------------------------

В настоящее время мы в api не поддерживаем возможность работы со старыми схемами базы. То есть если мы хотим поменять схему
базы, то мы должны ОДНОВРЕМЕННО с этим переключить API на новую версию. Таким образом переход на новую схему выглядит примерно так:
  - бэкапим текущую базу;
  - опускаем api (опционально, поскольку api проверяет поддерживает ли оно текущую схему базы);
  - мигрируем с помощью *yc-bootstrap-db-admin* на новую схем;
  - обновляем api на новую версию (которая поддерживает именно ту схему базы, на которую мы переключились);
  - проверяем, что все нормально.


Про дизайн схемы
------------------

Мы не настоящие сварщики и вряд ли хорошо понимаем принципы и правила проектирования,
не видим подводные ками и т.д. Поэтому если у кого есть соображения по этому поводу,
мы готовы перенять опыт.

Тем не менее хочется иметь некоторые правила, которые, кажется, будут полезными
(давайте обсудим этот вопрос).

Правила именования:
  - все имена в *lowercase*, отдельные слова разделяются через *underscope*;
  - все имена таблиц во *множественном* (исклюение - таблицы, содержащие ровно одну запись, их мы именуем в *единственном* числе);
  - для имен таблиц/полей не используем аббреиватуры и зарезервированные слова;
  - **CONSTRAINTS**:

    - **PRIMARY KEY**: **${table_name}_pkey**
    - **CHECK**: **${table_name}_ck_...**
    - **FOREIGN_KEY** : **${table_name}_${referenced_table_name}_fkey**
    - **UNIQUE**: **${table_name}_uq_${fiel1}_..._${fieldN}**
  - **INDEXES**: **${table_name}_ix_${field1}_..._${fieldN}**
  - **SEQUENCES**: **${table_name}_sq_pkey**

Другие правила:
  - всегда используем суррогатные первичные ключи (есил на таблицу существуют ссылки).


Полезные вещи
-------------

Проверка скрипта миграции локально
``````````````````````````````````

Пусть у нас уже есть две схемы и соответствующие им файлы:
  - *0.2.0/pg_dump.sql* - текущая схема;
  - *0.3.0/pg_dump.sql* - новая схема;
  - *0.3.0/migrate-from-0.2.0.sql* - скрипт для мигарации с *0.2.0* до *0.3.0*.

Последовательность команд для проверки того, что миграция делает то, что нужно:
  - *./bootstrap.db.admin start-db-in-docker* - делаем пустую базу;
  - *./bootstrap.db.admin populate --db-config localdb.yaml --bootstrap-file ../../schema/0.2.0/bootstrap.sql --version 0.2.0 --devel-database* - применяем текущую схему;
  - *./bootstrap.db.admin migrate --db-config localdb.yaml --migrate-file ../../schema/0.3.0/migrate-from-0.2.0.sql --version 0.3.0* - мигрируем на новую схему;
  - *./bootstrap.db.admin dump --db-config localdb.yaml --output-file pg_dump.sql --schema-only* - дампим текущую схема в файл;
  - *vimdiff pg_dump.sql ../../schema/0.3.0/pg_dump.sql* - сравниваем схему, полученную после миграции, со схемой, которая получается при бутстрапе с нуля (diff должен быть нулевой или околонулевой).

В случае, когда миграция меняет текущие данные (например, добавляется столбец в уже существующие таблицы), неплохо бы проверить, что все мигрируется адекватно, но не понятно, как это нормально автоматизировать.
