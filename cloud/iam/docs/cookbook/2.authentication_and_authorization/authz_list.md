Если результатом работы метода является список ресурсов (неважно частично или полностью будут возвращены данные
пользователю в этом списке, например, возврат списка идентификаторов в контексте авторизации не отличается от возврата
списка идентификаторов и имен), то сервис обязан убедиться, что пользователю возвращаются только те ресурсы, на которые
он имеет permission `<service>.<resource>.get`.

Например, при авторизации листинга всех ресурсов внутри контейнера сервис возвращает только те, к которым у пользователя
есть доступ:

```proto
service FolderService {
  rpc List (ListFoldersRequest) returns (ListFoldersResponse)
}

message ListFoldersRequest {
  string cloud_id = 1 [(required) = true, (length) = "<=50"];
  int64 page_size = 2 [(value) = "0-1000"];
  string page_token = 3 [(length) = "<=100"];
}
```

Если в контейнере `cloud1` находятся три каталога `folder1`, `folder2`, `folder3`, но права у пользователя есть только на
`folder2` и `folder3`, листинг с параметром `cloud_id='cloud1'` должен вернуть каталоги `folder2` и `folder3`.

Обратите внимание, что фильтрация ресурсов по правам при листинге в общем случае не должна приводить к уменьшению размера
результирующего списка ниже `page_size`, т.е. если в предыдущем примере был бы указан параметр `page_size=1`, то сервисам
_не рекомендуется_ возвращать пустой список и непустой `page_token` на первой странице и `folder2` на второй странице.

Если листинг происходит в контейнере (или так или иначе связан с каким-либо другим ресурсом, например по нему происходит
фильтрация результата работы метода), то применяются стандартные правила, работающие при авторизации ресурса в методах поиска:

- если контейнер с указанным идентификатором не найден, метод возвращает статус NotFound;
- если контейнер с указанным идентификатором существует, то возвращаются только те ресурсы, к которым у пользователя
  есть доступ в этом контейнере.

{% note alert %}

Может показаться, что можно соптимизировать проверку прав при листинге ресурсов в контейнере, делая предварительную
проверку наличия permission `<service>.<resource>.get` на самом контейнере. Права, назначенные на контейнер, сейчас
действительно автоматически наследуются на все ресурсы внутри него, однако в будущем такая проверка может привести
к ложноположительному срабатыванию (например, после появления deny-биндингов).

{% endnote %}

{% note info %}

На данный момент [не существует способа проверить права на множество ресурсов за один запрос](https://st.yandex-team.ru/CLOUD-8688).
Сервисы могут распараллеливать одиночные запросы на проверку прав по каждому ресурсу в отдельности во время листинга.

{% endnote %}

Если происходит листинг сущностей, не являющихся ресурсами, допускается использовать permission вида
`<service>.<resource>.list<something>`. В этом случае права проверяются на логический контейнер такой сущности. Примеры:

- `resource-manager.clouds.listAccessBindings` — проверяется на `resource-manager.cloud` 
- `iam.federations.listCertificates` — проверяется на `iam.federation`
- `iam.serviceAccounts.listAccessKeys` — проверяется на `iam.serviceAccount`

Для листинга ресурсов верхнего уровня используется механика ролей `member`/`owner`, описанная в разделе Специальные роли.
При этом в результат попадают только те ресурсы, где пользователь явно получил одну из этих ролей, т.е. в случае если
права на ресурс получены, например, через назначение соответствующей роли на псевдогруппу `allUsers`, такой ресурс не
будет показан пользователю (хотя при явном запросе `Get` на нем результат может быть получен).

{% note alert %}

Использование методов `MembershipService` не отменяет последующей проверки прав `<service>.<resource>.get` на каждом элементе
результата ее работы. Т.е. метод `GetMemberResources` дает лишь множество ресурсов, к которому у пользователю может быть
доступ, но наличие соответствующего доступа должен проверить вызывающий код.

Сделать универсальную проверку в самом `MembershipService`, к сожалению, нельзя, потому что этот метод может быть использован
для разных листингов, например, для листингов ресурсов, к которым у пользователя есть permission `<service>.<resource>.use`,
а не `<service>.<resource>.get`.

{% endnote %}
