## Примитивные роли

Примитивные роли появились в Облаке во время его запуска и включают 3 роли с очень широким списком полномочий:

- роль `viewer` — позволяет читать _метаданные_ и _данные_ ресурсов;
- роль `editor` — включает в себя все полномочия роли `viewer` и дополнительно позволяет редактировать
  _метаданные_ и _данные_ ресурсов, редактировать и удалять ресурсы, отменять операции;
- роль `admin` — в дополнение к полномочиям роли `editor` позволяет управлять правами на ресурсы и просматривать
  эти права.

Такие роли позволяют более-менее гибко управлять правами на ресурсы внутри облака, используя концепцию каталогов:
ресурсы распределяются по каталогам, разделяющих их на логически изолированные с точки зрения доступа группы, субъекты
получают соответствующую их уровню доступа примитивную роль на каталог, права распространяются с каталогов на
конкретные ресурсы в них.

В настоящее время крайне не рекомендуется использовать эти роли для управления доступами в сложных проектах, т.к.
они дают слишком много полномочий.

{% note info %}

Примитивные роли были сделаны по причине сжатых сроков на запуске Облака, т.к. не было возможности качественно
проработать модель сервисных ролей и уж тем более открыть конечным пользователям permission'ы и позволить им заводить
собственные роли.

{% endnote %}


## Специальные роли

Две специальные роли выделены в отдельную группу — роль `<service>.<resource>.member` и роль `<service>.<resource>.owner`.
Эти роли есть только в сервисах, управляющих ресурсами верхнего уровня (например, для облаков это роли
`resource-manager.clouds.member` и `resource-manager.clouds.owner`, а для платежных аккаунтов — роли `billing.accounts.member`
и `billing.accounts.owner`. Назначить их можно только на соответствующий им ресурс верхнего уровня. Роли должны быть
указаны при описании типа ресурса:

```yaml
resources:
  resource-manager.cloud:
    parents: [root]
    membership:
      roles: [resource-manager.clouds.member, resource-manager.clouds.owner]
```

При наличии каких-либо прав на ресурсе гарантируется (посредством сервисов IAM) наличие хотя бы одной из этих ролей на
ресурс верхнего уровня, в котором этот ресурс находится. Под наличием прав подразумевается именно возможность получить
тот или иной доступ к этому ресурсу, что вовсе не означает отсутствие биндингов на каком-либо ресурсе, лежащем внутри
ресурса верхнего уровня.

{% note alert %}

Из-за [недоработки в Access Service](https://st.yandex-team.ru/CLOUD-45995) указанная выше гарантия фактически не
выполняется.

{% endnote %}

Это сделано для того, чтобы обеспечить возможность пригласить пользователя получить доступ к ресурсам и иметь возможность
оперативно этот доступ забрать в условиях распределенного управления ресурсами в сервисах. Т.е. отрыв ролей
`<service>.<resource>.owner` и `<service>.<resource>.member` на корневом ресурсе в иерархии приводит к отрыву прав у
субъекта на все ресурсы, вложенные в него, и на сам ресурс непосредственно.

{% note info %}

Отрыв ролей `<service>.<resource>.owner` и `<service>.<resource>.member` на ресурсе верхнего уровня не приводит к удалению
биндингов прав на ресурсы, находящиеся внутри этого ресурса. После возвращения одной из этих ролей, оставшиеся права снова
дадут пользователю утраченный доступ.

{% endnote %}

Технически это реализуется заведением и проверкой дополнительного permission'а `iam.resourceTypes.membership` при проверке
прав на любой ресурс этой иерархии. Данный permission должен быть включен в роли `<service>.<resource>.owner` и
`<service>.<resource>.member`.

Т.к. сервисные аккаунты являются не только субъектами, но и ресурсами, находящимися внутри облаков, требование наличия роли
`<service>.<resource>.owner` или `<service>.<resource>.member` на облако для них не имеет смысла. Доступ к ресурсам,
находящимся не в облаке, которому принадлежит сервисный аккаунт, также не требует наличия этих ролей. Так сделано, потому
что внешним пользователям все равно запрещено выдавать доступ сервисным аккаунтам на ресурсы не из его облака, а внутренние
сервисы часто используют собственные системные сервисные аккаунты для доступа к ресурсам пользователя.

{% note info %}

Для того, чтобы выдавать сервисным аккаунтам доступ на ресурсы извне их облака необходимо обладать permission'ом
`iam.serviceAccounts.crossCloudBindings`.

{% endnote %}

При назначении прав на псевдогруппы `allUsers` и `allAuthenticatedUsers` наличия ролей `<service>.<resource>.owner` и
`<service>.<resource>.member` на корневом ресурсе у пользователей, получающих доступ к ресурсу, также не требуется.

{% note info %}

В будущем возможно появление политики назначения публичного доступа, которая будет контролировать возможность выдавать
публичный доступ на ресурсы внутри какого-либо контейнера (например, облака, каталоги или, в будущем, организации).

{% endnote %}

Еще одним важным назначением специальных сервисных ролей является возможность быстро получить список ресурсов верхнего уровня,
к которым пользователь имеет доступ, или получить список пользователей, которым можно назначить доступ на ресурсы,
находящиеся внутри некоторого ресурса верхнего уровня. Такая необходимость возникает при реализации методов `List` и
`ListUsers` в сервисах ресурсов верхнего уровня.

{% note info %}

Для ресурсов верхнего уровня это единственный разумный способ получения списка ресурсов, к которым пользователь имеет доступ,
позволяющий гарантировать, что пользователь видит только те ресурсы, к которым имеет доступ. В случае листинга ресурсов
внутри контейнера можно получить их все и проверить права на каждый в отдельности. Т.к. в контейнере всегда есть разумный
лимит на количество ресурсов в нем, это не вызывает сложности. Для ресурсов верхнего уровня такой способ не подходит, т.к.
для этого пришлось бы проверить права на все сущестсвующие ресурсы этого типа.

Подробнее про листинг ресурсов можно прочитать в разделе Листинг ресурсов.

{% endnote %}

```proto
service CloudService {
  rpc List (ListCloudsRequest) returns (ListCloudsResponse);
  rpc ListUsers (ListUsersRequest) returns (ListUsersResponse);
}

message ListCloudsRequest {
  int64 page_size = 1;
  string page_token = 2;
}

message ListUsersRequest {
  repeated string cloud_ids = 1;
  int64 page_size = 2;
  string page_token = 3;
}
```

Реализации этих методов должны использовать методы `MembershipService`:

```proto
service MembershipService {
  rpc ListResourceMembers (ListResourceMembersRequest) returns (ListResourceMembersResponse);
  rpc ListMemberResources (ListMemberResourcesRequest) returns (ListMemberResourcesResponse);
}

// Получить всех членов ресурса верхнего уровня типа "resource_type" с идентификатором "resource_id".
message ListResourceMembersRequest {
  string resource_id = 1;
  string resource_type = 2;
  int64 page_size = 3;
  string page_token = 4;
}

// Получить все ресурсы верхнего уровня типа "resource_type", членом которых является субъект "subject_id".
message ListMemberResourcesRequest {
  string subject_id = 1;
  string resource_type = 2;
  int64 page_size = 3;
  string page_token = 4;
}
```
