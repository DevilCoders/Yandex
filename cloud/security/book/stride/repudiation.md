## Repudiation

Repudiation - процедуры логгирования и аудита. Некорректная работа этих процедур приводит к невозможности выявлять инцидены, быстро и эффективно их расследовать, а также создает простор злоумышленнику для ответов "это был не я".

## Уровень инфраструктуры

### Бастион

Любой управляющий доступ, то есть доступ к POSIX API системы, на котрой работают наши сервисы (например, доступ по ssh или через kubectl exec) должен осуществляться при помощи сервиса Бастион.

{% note alert %}

Использование сервиса Бастион является обязательным для всех сервисов Облака. Прямой доступ к POSIX API систем - запрещен.

{% endnote %}

### Проброс портов

По умолчанию мы ограничиваем количество портов, доступных для проброса в сервисе Бастион. При моделировании угроз надо определить есть ли в сервисе необходимость использования проброса портов и проговорить защиту от связанных с этим угроз.

### Уровень операционной системы

На уровне операционной системы есть несколько важных источников логов, которые необходимо настроить и собирать.

#### Syslog (sshd и sudo)

Логи логинов по ssh и логи запусков sudo должны быть настроены и отправлять сообщения об успешных и неуспешних попытках доступа. Неуспешные попытки доступа по ssh являются хорошим индикатором попыток развития атаки злоумышленником (lateral movement).

Как настроить логгирование на уровне операционной системы:

**TBD**

#### Osquery

Osquery является универсальным агентом, собирающим телеметрию из операционной системы - информацию о процессах, пользователях, настройках, версиях установленных пакетов и приложений. Osquery должен работать в каждой виртуальной машине сервиса.

{% note tip %}

Для получения корректного конфига для Osquery необходимо обратиться к команде Security.

{% endnote %}

### Уровень сервиса

Корректное логгирование должно быть реализовано на уровне сервиса. В основном, в Облаке для этого надо интегрироваться с сервисов Audit Trails.

### Общие требования к логам

В общем случае, логи должны быть такими, чтобы давать ответы на следующие вопросы:

* who? - кто совершил действие (субъект)
* when? - когда действие было совершено (метка времени)
* which? - что за действие было совершено (название действия)
* why? - почему действие было совершено (успешная авторизация) или наоборот не совершено - неуспешная авторизация.

### Уровень Control Plane - Audit Trails

При моделировании угроз сервиса необходимо определить control plane события и договориться об отправке этих событий в сервис Audit Trails.

В дальнейшем эти события будут доступны внешним пользователям, а также команда Security сможет сделать на их основе набор алертов.

{% note alert %}

Интеграция с сервисов Audit Trails обязательна для всех сервисов, которые выходят в GA. Это является одним из показателей качества сервиса - таким же как и наличие публичного API или поддержки в terraform.

{% endnote %}

### Уровень Data Plane - логгирование в API, data access logs

В настоящий момент Audit Trails не поддерживает сбор Data Access логов, поэтому логи надо собирать самостоятельно и отправлять в YT через push client или unified agent.

{% note alert %}

Необходимо собирать информацию не только о доступе к данным, но и о попытках такого доступа. Под попытками мы понимаем случай, когда была успешная аутентификация (например, запрос с валидным токеном), но запрос не был авторизован (не хватило прав для авторизации, получили permission denied от IAM и так далее).

{% endnote %}

### Уровень веб-интерфейсов

Логгирование должно быть также реализовано на уровне веб-интерфейса, если у него есть back-end (например, node.js приложение).

При моделировании угроз надо также проговорить проброс request id и оригинального IP-адреса пользователя (а не адреса L7/ALB балансера) в API, для последующей корректной записи этой информации в логи и в сервис Audit Trails.
