## Генератор дашбордов для Grafana

### FAQ

**Q**: Почему важно стремиться не допускать расхождений спецификации и построенного по ней дашборда?

**A**: Single point of truth в виде лежащей в VCS спецификации и регулярное обновление дашборда по ней позволяют,
       при внесении изменений, видеть в резульате генерации лишь небольшой набор релевантных изменений. Кроме того, это
       даёт возможность убеждаться в сохранении обратной совместимости при добавлении в генератор новых возможностей. 

**Q**: Как использовать `@variable` и `$variable`?

**A**: `@variable` – статические переменные. Они определяются явно в секции `/variables/replacement`, а также неявно
       в контексте дублируемых с помощью директивы `repeat` рядов и панелей. Особенность этих переменных в том,
       что они доступны только на на этапе работы генератора. Они позволяют задать для каждого ключа
       одно (в `replacement`) или кортеж из нескольких (в `repeat`) значений, которые можно подставлять в любые строковые выражения.
       `$variable`, в свою очередь – динамические переменные, доступные лишь позднее, при фактическом использовании
       дашборда. Они задаются в UI Grafana. С их помощью можно не только менять заголовки панелей и значения меток сенсоров,
       но и динамически фильтровать (`multi: false`), повторять и менять количество (`multi: true`) панелей и рядов.
       Оба класса переменных можно испольовать и вместе, но лишь строго последовательно: `@variable`, затем `$variable`.
       К примеру, можно продублировать график количества обращений к клиентам с помощью `@clientType` (`repeat: clientType`),
       а затем менять в получившихся копиях текущее окружение с помощью `$env` (`preprod` | `prod`).
       Однако, нельзя, например, указать кондукторную группу: `conductor: group_at_${env}` для создания
       отдельного графика по каждому из её хостов. Впрочем, в случае поддержки динамических `Query`-переменных
       в `Grafana Solomon Plugin` в будущем, такие сценарии могут стать возможными.  

**Q**: Как указать различный набор хостов для `preprod` и `prod`?

**A**: Это часто необходимо для организации повторяющихся рядов графиков – по ряду на хост и/или ДЦ. Варианты:  
       - [uiQuery-переменная](REFERENCE.md#ui-query-селекторы) (фактическое множество значений метки в сенсорах);  
       - [!include](REFERENCE.md#параметризованные-включения-вложенных-спецфикаций) +
         [conductor](REFERENCE.md#интеграция-с-conductor) (отдельные дашборды, отличающиеся набором статических параметров);  
       - если хосты имеют семантическое имя (а не являются, например, id) и их мало либо их можно сгруппировать по ДЦ, можно
         указать их вручную, как в [этом примере](REFERENCE.md#drilldown).  
       См. также раздел [замечания](REFERENCE.md#замечания).

**Q**: Каковы этапы обработки спецификации?

**A**: Вначале происходит чтение основной спецификации из файла. При этом рекурсивно **на уровне строк (а не yaml)**,
       обрабатываются параметризованные директивы включения других файлов (`!include ...`).
       Далее происходит описанный ниже процесс. Он применяется вначале для этой основной спецификации,
       а затем и для каждой дочерней – полученной в процессе работы генератора (пример: drilldown-дашбррды):
- resolution статических `replacement`-переменных. Переменные подставляются в другие переменные, а затем в спецификацию;
- создание дашборда:
  - resolution ui-переменных, включая разворачение `conductor`-групп в список хостов или дерево подгрупп (ДЦ/хосты).
    ⓘ Аналогичный resolution происходит и ниже для директив `repeat` – непосредственно перед обработкой.
  - создание output-структуры дашборда;
- создание рядов; при этом, обрабатываются статические повторы рядов (`repeat`).
  Для каждого ряда (или для всего дашборда, если дашборд не содержит рядов):
  - создаются панели: графики, "светофоры", placeholder'ы и т.д., а также обрабатываются статические повторы панелей
    (`repeat` – директива пока доступна только для графиков).
    Для каждой панели производятся (некоторые – в зависимости от её типа) действия:
    - resolve параметров "по умолчанию" для графика и каждого из его `query`:
      `graphDefaults` в порядке приоритета "мёржатся" с `[graph.]params`,
      а `queryDefaults` – с `[graph.queries[i].]params`;
    - resolve (с учётом подстановки `replacement-` и `repeat-`переменных и параметров "по умолчанию")
      последовательности шаблонов и её применение к исходной спецификации панели, в результате чего
      её, как правило, простая и компактная спецификация преобразуется в развёрнутый финальный вид;
    - преобразование спецификации панели в (output) структуру;
- каждый из полученных дашбордов (основной и дочерние), при необходимости (`action=diff`), сравнивается с remote-версией
  в Grafana и затем (для `action=upload`, при наличии изменений) заменяет её;

**Q**: Можно ли агрегировать сенсоры на графике, оставив переменными две метки?

**A**: Да, например: `select: { ... group_by_labels: [sum, label1, label2], alias: 'Line for {{label1}} and {{label2}}' }`

**Q**: Можно ли отсортировать значения в legend, например, в случае `label=*`?

**A**: Такой возможности пока нет, но можно указать линии явно. Для уменьшения кода можно
       вынести общие метки на уровень графика: `[graph.]queryDefaults: { labels: ... }`,
       либо использовать шаблоны (например,
       [percentile](https://a.yandex-team.ru/arc/trunk/arcadia/cloud/java/dashboard/src/main/java/yandex/cloud/dashboard/model/spec/panel/template/PercentileTemplate.java?rev=6516178#L29)),
       которые продублируют нужные линии самостоятельно.

**Q**: Как эффективно перенести в спецификацию дашборд, созданный в Grafana вручную?

**A**: Автоматического конвертера из Grafana в yaml-спецификацию в настоящий момент нет, и его создание пока не планируется.
       Однако поскольку значительную часть времени занимает указание меток (`queries/params/labels`) на графиках,
       процесс переноса вручную можно ускорить с помощью следующих шагов:
- открыть дашборд в Grafana;
- открыть нужный график в режиме редактирования (`Edit`);
- выбрать запрос, нажать `Sensors in admin`;
- после перехода в UI Solomon, нажать `Show graph`;
- нажать кнопку копирования (⎘) справа от перечня меток;
- вставить полученную строку с перечнем меток в yaml-спецификацию
  (опционально, двойные кавычки в значениях меток можно убрать).

Примеры указания `labels` можно найти [здесь](REFERENCE.md#параметры-запроса-в-графике).

**Q**: Можно ли по выбранному значению одной `ui`-переменной задать определённый набор значений для другой `ui`-переменой,
       или, хотя бы, задать маппинг 1-к-1 (выбор одноврменно кортежа значений)?

**A**: Такой возможности сейчас нет, но есть несколько workaround'ов.
       Подробнее об этом и возможные ситуации описаны [здесь](REFERENCE.md#замечания).
